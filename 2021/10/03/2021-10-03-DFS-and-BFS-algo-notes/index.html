<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Welcome to my personal blogs">
    <meta name="author" content="Yuxuan Wu">
    
    <title>
        
            DFS and BFS algo notes |
        
        Yuxuan Wu
    </title>
    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep coding, Keep hungry."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.3.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days age","week":"%s weeks age","month":"%s months age","year":"%s years age"};
  </script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Yuxuan Wu
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content normal-code-theme">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">DFS and BFS algo notes</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Yuxuan Wu</span>
                        <span class="level">Lv13</span>
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i> 2021-10-03 09:47:23
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/CMUAlgoNotes/">CMUAlgoNotes</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/BFS/">BFS</a>
                    </li>
                
                    <li>
                        | <a href="/tags/graph/">graph</a>
                    </li>
                
                    <li>
                        | <a href="/tags/DFS/">DFS</a>
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i> <span>3.1k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i> <span>18 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="General-Tree-growing"><a href="#General-Tree-growing" class="headerlink" title="General Tree growing"></a>General Tree growing</h1><ul>
<li>Let T be the current tree</li>
<li>Maintain a list of <code>frontier edges </code>: the set of edges of F that have one endpoint in T and one endpoint not in T</li>
<li>Repeatedly choose a frontier edge (somehow) and add it to T</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211027122244.png" alt="image-20211027122241449"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211027122338.png" alt="image-20211027122337067"></p>
<h2 id="Implementation-of-tree-growing"><a href="#Implementation-of-tree-growing" class="headerlink" title="Implementation of tree growing"></a>Implementation of tree growing</h2><ol>
<li>DFS</li>
<li>BFS</li>
<li>Prim’s algorithms</li>
<li>Dijkstra’s shortest path</li>
<li>A*</li>
</ol>
<h2 id="BFS-amp-DFS-as-Tree-Growing"><a href="#BFS-amp-DFS-as-Tree-Growing" class="headerlink" title="BFS & DFS as Tree Growing"></a>BFS &amp; DFS as Tree Growing</h2><ol>
<li><code>nextEdge()</code> for DFS:<ul>
<li>Select a frontier edge whose tree endpoint was discovered <code>most recently</code> (Stack)</li>
<li>Run time for DFS: O(E)</li>
</ul>
</li>
<li><code>nextEdge()</code>for BFS<ul>
<li>Select a frontier edge whose tree endpoint was discovered <code>least recently</code> (Queue)</li>
<li>Run time for BFS: O(E)</li>
</ul>
</li>
</ol>
<h2 id="nextEdge-for-BFS"><a href="#nextEdge-for-BFS" class="headerlink" title="nextEdge for BFS"></a>nextEdge for BFS</h2><p><code>nextEdge:</code> frontier edge connecting to node with earliest discovery time</p>
<p>A queue maintains a list of items in order of their discovery so that the item discovered farthest in the past can be accessed quickly</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211027125655.png" alt="image-20211027125653396"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">procedure bfs(G,root) is</span><br><span class="line">	let Q be a queue </span><br><span class="line">	mark root as explored</span><br><span class="line">	Q.enqueue(root)</span><br><span class="line">	while Q is not empty do</span><br><span class="line">		v:= Q.dequeue</span><br><span class="line">		if v is the goal then return v</span><br><span class="line">		for all edges from v to w in G.adjacnetEdges(v) do </span><br><span class="line">			if w is not marked then label w as explored</span><br><span class="line">				Q.enqueue(w)</span><br></pre></td></tr></table></figure>


<h2 id="nextEdge-for-DFS"><a href="#nextEdge-for-DFS" class="headerlink" title="nextEdge for DFS"></a>nextEdge for DFS</h2><p><code>nextEdge:</code> frontier edge connecting to node with latest discovery time</p>
<p>A stack maintains a list of items so they can be accessed in reverse order of their discovery times </p>
<p>A stack is a “last in, first out” (LIFO) data structure</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211027130412.png" alt="image-20211027130411328"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">procedure DFS(G,s)</span><br><span class="line">	S:= stack containing only s</span><br><span class="line">	S.push(s)</span><br><span class="line">	while s not empty</span><br><span class="line">		v:= s.pop()</span><br><span class="line">		if v is not visited:</span><br><span class="line">			mark v as visited</span><br><span class="line">			for w in G.neighbors(v):</span><br><span class="line">				s.push(w)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Recursion based implementation</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">procedure dfs (G,u)</span><br><span class="line">	mark u as visited</span><br><span class="line">	while u has an unvisited neighbor in G</span><br><span class="line">		v:= an unvisited neighbor of u</span><br><span class="line">		dfs(G,u)</span><br></pre></td></tr></table></figure>


<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="Basic-idea"><a href="#Basic-idea" class="headerlink" title="Basic idea"></a>Basic idea</h2><ul>
<li><p>DFS keeps walking down a path until it forced to backtrack</p>
</li>
<li><p>It backtrack until find a new path to go down </p>
</li>
<li><p>The overall results would be a <code>DFS tree</code></p>
</li>
<li><p>LIFO (Last IN First OUT Method)</p>
</li>
</ul>
<h2 id="Non-DFS-Tree-edges"><a href="#Non-DFS-Tree-edges" class="headerlink" title="Non-DFS-Tree edges"></a>Non-DFS-Tree edges</h2><p>Theorem: Let x and y be nodes in the <code>DFS tree</code> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex" xmlns="http://www.w3.org/2000/svg" width="2.692ex" height="1.906ex" role="img" focusable="false" viewBox="0 -677 1189.8 842.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(584, -150) scale(0.707)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></g></svg></mjx-container> such that {x,y} is an edge in a undirected graph G. Then one of x or y is an ancestor of the other in <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex" xmlns="http://www.w3.org/2000/svg" width="2.692ex" height="1.906ex" role="img" focusable="false" viewBox="0 -677 1189.8 842.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(584, -150) scale(0.707)"><path data-c="1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></g></g></g></g></svg></mjx-container></p>
<h2 id="Recursive-implementation-of-DFS"><a href="#Recursive-implementation-of-DFS" class="headerlink" title="Recursive implementation of DFS"></a>Recursive implementation of DFS</h2><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><ol>
<li>Create a recursive function that takes the index of the node and a visited array</li>
<li>Mark the current node/vertex as visited and print the node (this would be further code processing part)</li>
<li>Traverse all the adjacency and mark all the nodes and recursively use the dfs functions</li>
</ol>
<h3 id="pseudo-code"><a href="#pseudo-code" class="headerlink" title="pseudo code"></a>pseudo code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">procedure dfs (G,u)</span><br><span class="line">	mark u as visited</span><br><span class="line">	while u has an unvisited neighbor in G</span><br><span class="line">		v:= an unvisited neighbor of u</span><br><span class="line">		dfs(G,u)</span><br></pre></td></tr></table></figure>
<h3 id="Java-implementation"><a href="#Java-implementation" class="headerlink" title="Java implementation"></a>Java implementation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFS</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creat the DFS object</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use DFS to find all the adjacent point in graph G</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph g, <span class="keyword">int</span> v)</span> </span>{</span><br><span class="line">        <span class="comment">// mark vertex v as visited</span></span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">      	<span class="comment">// print the vertex v, if further process needs, type code in this place</span></span><br><span class="line">        System.out.println(v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate through all the neighbor, obtain each vertex w</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : g.adj(v)) {</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) dfs(g, w);</span><br><span class="line">        }</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether w and s are connected</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">visited</span><span class="params">(<span class="keyword">int</span> w)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> visited[w];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// obtain the number of vertex that is connected to vertex s</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<h3 id="Stack-based-implantation-of-DFS"><a href="#Stack-based-implantation-of-DFS" class="headerlink" title="Stack based implantation of DFS"></a>Stack based implantation of DFS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">procedure DFS(G,s)</span><br><span class="line">	S:= stack containing only s</span><br><span class="line">	S.push(s)</span><br><span class="line">	while s not empty</span><br><span class="line">		v:= s.pop()</span><br><span class="line">		if v is not visited:</span><br><span class="line">			mark v as visited</span><br><span class="line">			for w in G.neighbors(v):</span><br><span class="line">				s.push(w)</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFS_Stack</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DFS_Stack</span><span class="params">(Graph g, <span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.V(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) dfs(g, s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph g, <span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">        <span class="comment">// create a stack used to do iterative DFS</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// push the source node into stack</span></span><br><span class="line">        stack.push(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// while s not empty</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty()) {</span><br><span class="line">            <span class="comment">// pop a vertex from the</span></span><br><span class="line">            <span class="keyword">int</span> v = stack.pop();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if the vertex v is already visited, we would ignore it</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// the vertex v is not yet visited, we would mark as true</span></span><br><span class="line">            visited[v] = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(v);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do for every edge v-&gt;w</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Integer w : g.adj(v)) {</span><br><span class="line">                <span class="keyword">if</span> (!visited[w]) {</span><br><span class="line">                    stack.push(w);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>




<h3 id="Comparison-of-recursively-achieved-and-stack-based-algorithm"><a href="#Comparison-of-recursively-achieved-and-stack-based-algorithm" class="headerlink" title="Comparison of recursively achieved and stack-based algorithm"></a>Comparison of recursively achieved and stack-based algorithm</h3><p>These two variations of DFS visit the neighbors of each vertex in the opposite order from each other: the first neighbor of <em>v</em> visited by the recursive variation is the first one in the list of adjacent edges, while in the iterative variation the first visited neighbor is the last one in the list of adjacent edges. </p>
<blockquote>
<p>The recursive implementation will visit the nodes from the example graph in the following order: A, B, D, F, E, C, G. </p>
<p>The non-recursive implementation will visit the nodes as: A, E, F, B, D, C, G.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211004163957.png" alt="An undirected graph with edges AB, BD, BF, FE, AC, CG, AE"></p>
<p>The non-recursive implementation is similar to <a class="link" target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search<i class="fas fa-external-link-alt"></i></a> but differs from it in two ways:</p>
<ol>
<li>it uses a stack instead of a queue, and</li>
<li>it delays checking whether a vertex has been discovered until the vertex is popped from the stack rather than making this check before adding the vertex.</li>
</ol>
<p>If <em>G</em> is a <a class="link" target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tree_(data_structure)">tree<i class="fas fa-external-link-alt"></i></a>, replacing the queue of the breadth-first search algorithm with a stack will yield a depth-first search algorithm. For general graphs, replacing the stack of the iterative depth-first search implementation with a queue would also produce a breadth-first search algorithm, although a somewhat nonstandard one.[<a class="link" target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Depth-first_search#cite_note-7">7]<i class="fas fa-external-link-alt"></i></a></p>
<p>Another possible implementation of iterative depth-first search uses a stack of <a class="link" target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Iterator">iterators<i class="fas fa-external-link-alt"></i></a> of the list of neighbors of a node, instead of a stack of nodes. This yields the same traversal as recursive DFS.[<a class="link" target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Depth-first_search#cite_note-8">8]<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="Topological-sorting-DFS-application"><a href="#Topological-sorting-DFS-application" class="headerlink" title="Topological sorting (DFS application)"></a>Topological sorting (DFS application)</h2><h3 id="DAGs"><a href="#DAGs" class="headerlink" title="DAGs"></a>DAGs</h3><p>A directed, acyclic graph (DAG) is a graph that contains no directed cycles. (After leaving any node u can never get back to u by following edges along the arrows)</p>
<blockquote>
<p>DAGs are very useful in modeling project dependencies: Task i has to be done before task j and k which have to be done before m</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211005090554.png" alt="image-20211005090551103"></p>
<h3 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem:"></a>Theorem:</h3><blockquote>
<ol>
<li>Every DAG contains a vertex with no incoming edges. </li>
</ol>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211027183534.png" alt="image-20211027183533161"></p>
<blockquote>
<ol start="2">
<li>If a directed graph G is a DAF, then G has a topological ordering. Also, if a directed graph G has a topological ordering, then G is a DAG. </li>
</ol>
</blockquote>
<p>Being a DAG &lt;=&gt; having a topological ordering, because a topological ordering implies that there are no cycles in the directed graph. </p>
<h3 id="Topological-sorting-algorithm"><a href="#Topological-sorting-algorithm" class="headerlink" title="Topological sorting algorithm"></a>Topological sorting algorithm</h3><blockquote>
<p>Topological sort:</p>
</blockquote>
<ol>
<li>Let i = 1 </li>
<li>Find a node u with no incoming edges, and let f(u) = i</li>
<li>Delete u from the graph</li>
<li>Increment I</li>
</ol>
<blockquote>
<p>Implementation: Maintain</p>
</blockquote>
<ol>
<li>Income[w] = number of incoming edges for node w</li>
<li>A list S of nodes that currently have no incoming edges</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031131844.png" alt="Topological-Sorting"></p>
<p>When we delete a node u, we decrement Income[w] for all neighbors w of u. If Income[w] becomes 0, we add w to S.</p>
<p><code>Topological sorting</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.linear.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopoLogical</span> </span>{</span><br><span class="line">    <span class="comment">//顶点的拓扑排序</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; order;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造拓扑排序对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopoLogical</span><span class="params">(Digraph G)</span> </span>{</span><br><span class="line">        <span class="comment">//创建一个检测有向环的对象</span></span><br><span class="line">        DirectedCycle cycle = <span class="keyword">new</span> DirectedCycle(G);</span><br><span class="line">        <span class="comment">//判断G图中有没有环，如果没有环，则进行顶点排序：创建一个顶点排序对象</span></span><br><span class="line">        <span class="keyword">if</span> (!cycle.hasCycle()){</span><br><span class="line">            DepthFirstOrder depthFirstOrder = <span class="keyword">new</span> DepthFirstOrder(G);</span><br><span class="line">            order = depthFirstOrder.reversePost();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断图G是否有环</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> order==<span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取拓扑排序的所有顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stack&lt;Integer&gt;  <span class="title">order</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>DepthFirstOrder</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.linear.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstOrder</span> </span>{</span><br><span class="line">    <span class="comment">//索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">//使用栈，存储顶点序列</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; reversePost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个检测环对象，检测图G中是否有环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstOrder</span><span class="params">(Digraph G)</span></span>{</span><br><span class="line">        <span class="comment">//初始化marked数组</span></span><br><span class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//初始化reversePost栈</span></span><br><span class="line">        <span class="keyword">this</span>.reversePost = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历图中的每一个顶点，让每个顶点作为入口，完成一次深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>;v&lt;G.V();v++){</span><br><span class="line">            <span class="keyword">if</span> (!marked[v]){</span><br><span class="line">                dfs(G,v);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于深度优先搜索，把顶点排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">        <span class="comment">//标记当前v已经被搜索</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//通过循环深度搜索顶点v</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) {</span><br><span class="line">            <span class="comment">//如果当前顶点w没有搜索，则递归调用dfs进行搜索</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[w]){</span><br><span class="line">                dfs(G,w);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//让顶点v进栈</span></span><br><span class="line">        reversePost.push(v);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶点线性序列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stack&lt;Integer&gt;  <span class="title">reversePost</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> reversePost;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>DirectedCycle</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span> </span>{</span><br><span class="line">    <span class="comment">//索引代表顶点，值表示当前顶点是否已经被搜索</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">//记录图中是否有环</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle;</span><br><span class="line">    <span class="comment">//索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个检测环对象，检测图G中是否有环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedCycle</span><span class="params">(Digraph G)</span></span>{</span><br><span class="line">        <span class="comment">//初始化marked数组</span></span><br><span class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//初始化hasCycle</span></span><br><span class="line">        <span class="keyword">this</span>.hasCycle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//初始化onStack数组</span></span><br><span class="line">        <span class="keyword">this</span>.onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到图中每一个顶点，让每一个顶点作为入口，调用一次dfs进行搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v =<span class="number">0</span>; v&lt;G.V();v++){</span><br><span class="line">            <span class="comment">//判断如果当前顶点还没有搜索过，则调用dfs进行搜索</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[v]){</span><br><span class="line">                dfs(G,v);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于深度优先搜索，检测图G中是否有环</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line">        <span class="comment">//把顶点v表示为已搜索</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把当前顶点进栈</span></span><br><span class="line">        onStack[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行深度搜索</span></span><br><span class="line">        <span class="keyword">for</span> (Integer w : G.adj(v)) {</span><br><span class="line">            <span class="comment">//判断如果当前顶点w没有被搜索过，则继续递归调用dfs方法完成深度优先搜索</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[w]){</span><br><span class="line">                dfs(G,w);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断当前顶点w是否已经在栈中，如果已经在栈中，证明当前顶点之前处于正在搜索的状态，那么现在又要搜索一次，证明检测到环了</span></span><br><span class="line">            <span class="keyword">if</span> (onStack[w]){</span><br><span class="line">                hasCycle = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//把当前顶点出栈</span></span><br><span class="line">        onStack[v] = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前有向图G中是否有环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> hasCycle;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<h3 id="Run-time-analysis"><a href="#Run-time-analysis" class="headerlink" title="Run time analysis"></a>Run time analysis</h3><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211027193803.png" alt="image-20211027193801873"></p>
<h3 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h3><blockquote>
<p>Design an algorithm to determine whether a DAG has a unique topological ordering</p>
</blockquote>
<p>We would firstly run a topological sort on G, since this is a DAG. Denote this order as L, we then check whether there is an edge going from first node in L to the second node in L. Similarly check the edge from second to third. Repeatedly check all the vertices. If all of the vertices follow the previous rules, then return true, it has a unique topological ordering, otherwise, return false. </p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211004173740.png" alt="image-20211004173738005"></p>
<h2 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">procedure bfs(G,root) is</span><br><span class="line">	let Q be a queue </span><br><span class="line">	mark root as explored</span><br><span class="line">	Q.enqueue(root)</span><br><span class="line">	while Q is not empty do</span><br><span class="line">		v:= Q.dequeue</span><br><span class="line">		if v is the goal then return v</span><br><span class="line">		for all edges from v to w in G.adjacnetEdges(v) do </span><br><span class="line">			if w is not marked then label w as explored</span><br><span class="line">				Q.enqueue(w)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>Java implementation</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFS</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; waitSearch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.waitSearch = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        bfs(G,s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>{</span><br><span class="line">        <span class="comment">// mark v as visited</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// let v in the queue, ready to search</span></span><br><span class="line">        waitSearch.add(v);</span><br><span class="line"></span><br><span class="line">        System.out.println(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!waitSearch.isEmpty()) {</span><br><span class="line">            Integer wait = waitSearch.remove();</span><br><span class="line">            <span class="comment">// iterate wait's adjacency matrix</span></span><br><span class="line">            <span class="keyword">for</span> (Integer w : G.adj(wait)) {</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) {</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    waitSearch.add(w);</span><br><span class="line">                    System.out.println(w);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// let connected vertex +1</span></span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">marked</span><span class="params">(<span class="keyword">int</span> w)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> marked[w];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<h2 id="Finding-all-connected-components"><a href="#Finding-all-connected-components" class="headerlink" title="Finding all connected components"></a>Finding all connected components</h2><h3 id="Bipartiteness"><a href="#Bipartiteness" class="headerlink" title="Bipartiteness"></a>Bipartiteness</h3><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211004193624.png" alt="image-20211004193619901"></p>
<blockquote>
<p>Solution:</p>
</blockquote>
<ol>
<li>Do a BFS starting from some node s</li>
<li>Color even levels “blue” and odd levels “red”</li>
<li>Check each edge to see if any edge has both endpoints the same level</li>
</ol>
<blockquote>
<p>Notice:</p>
</blockquote>
<p>Nodes in adjacent levels must get different colors because by construction there are edges between adjacent levels</p>
<blockquote>
<p>Proof of Correctness for Bipartite Testing</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211027182054.png" alt="image-20211027182052500"></p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211102092812.png" alt="image-20211027182106903"></p>
<h3 id="Bipartite-Graph-Checker"><a href="#Bipartite-Graph-Checker" class="headerlink" title="Bipartite Graph Checker"></a>Bipartite Graph Checker</h3><p>We can use the O(<strong>V</strong>+<strong>E</strong>) DFS or BFS (they work similarly) to check if a given graph is a Bipartite Graph by giving alternating color (orange versus blue in this visualization) between neighboring vertices and report ‘non bipartite’ if we ends up assigning same color to two adjacent vertices or ‘bipartite’ if it is possible to do such ‘2-coloring’ process. Try DFS_Checker or BFS_Checker on the example Bipartite Graph.</p>
<p>Bipartite Graphs have useful applications in <a class="link" target="_blank" rel="noopener" href="https://visualgo.net/en/matching">(Bipartite) Graph Matching problem<i class="fas fa-external-link-alt"></i></a>.</p>
<p>Note that Bipartite Graphs are usually only defined for undirected graphs so this visualization will convert directed input graphs into its undirected version automatically before continuing. This action is irreversible and you may have to redraw the directed input graph again for other purposes.</p>
<h1 id="Applications-1"><a href="#Applications-1" class="headerlink" title="Applications"></a>Applications</h1><h2 id="Detecting-cycle"><a href="#Detecting-cycle" class="headerlink" title="Detecting cycle"></a>Detecting cycle</h2><p>We can actually <em>augment</em> the basic DFS further to give more insights about the underlying graph.</p>
<p>In this visualization, we use blue color to highlight <strong>back</strong> edge(s) of the DFS spanning tree. The presence of at least one back edge shows that the traversed graph (component) is <strong>cyclic</strong> while its absence shows that at least the component connected to the source vertex of the traversed graph is <strong>acyclic</strong>.</p>
<p>Back edge can be detected by modifying array <strong>status[u]</strong> to record <strong>three</strong> different states:</p>
<ol>
<li><strong>unvisited</strong>: same as earlier, DFS has not reach vertex <strong>u</strong> before,</li>
<li><strong>explored</strong>: DFS has visited vertex <strong>u</strong>, but at least one neighbor of vertex <strong>u</strong> has not been visited yet (DFS will go depth-first to that neighbor first),</li>
<li><strong>visited</strong>: now stronger definition: all neighbors of vertex <strong>u</strong> have also been visited and DFS is about to backtrack from vertex <strong>u</strong> to vertex <strong>p[u]</strong>.</li>
</ol>
<p>If DFS is now at vertex <strong>x</strong> and explore edge <strong>x → y</strong> and encounter <strong>status[y] = explored</strong>, we can declare <strong>x → y</strong> is a <strong>back edge</strong> (a cycle is found as we were previously at vertex <strong>y</strong> (hence <strong>status[y] = explored</strong>), go deep to neighbor of <strong>y</strong> and so on, but we are now at vertex <strong>x</strong> that is reachable from <strong>y</strong> but vertex <strong>x</strong> leads back to vertex <strong>y</strong>).</p>
<p>The edges in the graph that are not tree edge(s) nor back edge(s) are colored grey. They are called <strong>forward or cross edge(s)</strong> and currently have limited use (not elaborated).</p>
<p>Now try DFS(0) on the example graph above with this new understanding, especially about the 3 possible status of a vertex (unvisited/normal black circle, explored/blue circle, visited/orange circle) and back edge. Edge 2 → 1 will be discovered as a back edge as it is part of cycle 1 → 3 → 2 → 1 (similarly with Edge 6 → 4 as part of cycle 4 → 5 → 7 → 6 → 4).</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031112906.png" alt="image-20211031112905258"></p>
<p>We can use following simple recursive function to print out the path stored in array <strong>p</strong>. Possible follow-up discussion: Can you write this in <strong>iterative</strong> form? (trivial)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">method backtrack(u)</span><br><span class="line">  if (u == -1) stop</span><br><span class="line">  backtrack(p[u]);</span><br><span class="line">  output vertex u</span><br></pre></td></tr></table></figure>
<p>To print out the path from a source vertex <strong>s</strong> to a target vertex <strong>t</strong> in a graph, you can call O(<strong>V</strong>+<strong>E</strong>) DFS(s) (or BFS(s)) and then O(<strong>V</strong>) backtrack(t). Example: <strong>s = 0</strong> and <strong>t = 4</strong>, you can call DFS(0) and then backtrack(4). When we call backtrack(4) after executing DFS(0) on the sample graph, we go back from 4 → p[4] = 3 → p[3] = 2 → p[2] = 1 → p[1] = 0 → p[0] = -1 (so 0 is the source) and print the path in reversed order (due to recursion) i.e.: 0 → 1 → 2 → 3 → 4.<img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031113446.png" alt="image-20211031113443782"></p>
<h2 id="Q4-in-midterm-practice"><a href="#Q4-in-midterm-practice" class="headerlink" title="Q4 in midterm practice"></a>Q4 in midterm practice</h2><p>Design an algorithm to take an undirected, connected graph G(V,E) and give each of its edge a direction such the following two conditions are satisfied:</p>
<ol>
<li>The resulting directed graph contains a tree all of whose edges point away from the root</li>
<li>Any edge that does not belong to the above tree forms a directed cycle with edges of the tree (A directed cycle is a cycle in which all the edges are going the same way)</li>
</ol>
<h3 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h3><p>We shall run DFS to produce a tree and then flip the edges not in the tree appropriately</p>
<ul>
<li>Run DFS. As we traverse the edges during DFS we create the directed edge from parent to child, ensuring that all edges face away from the root. At the same time, we timestamp each node such that we know the order in which we visited them (which will be necessary to easily decide the direction of non-tree edges) This satisfies the first condition.</li>
<li>We then deal with the remaining edges. Every edge will connect two nodes, and every node is timestamped. We direct non-tree edges from the more recent node to the older node. This ensures that it points back to a node that will form a cycle (and this relies on the traversal ordering provided by DFS)</li>
</ul>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：DFS and BFS algo notes</li>
        <li>Post author：Yuxuan Wu</li>
        <li>Create time：2021-10-03 09:47:23</li>
        <li>
            Post link：yuxuanwu17.github.io2021/10/03/2021-10-03-DFS-and-BFS-algo-notes/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/10/03/2021-10-03-Undirected-Graph-implementation-in-Java/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Undirected Graph implementation in Java</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/09/02/2021-09-02-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">图论基础</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span> -
            
            2021 <i class="fas fa-heart icon-animate"></i> <a href="/">Yuxuan Wu</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count <span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a> | Theme <a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.3.1</a>
        </div>
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#General-Tree-growing"><span class="nav-number">1.</span> <span class="nav-text">General Tree growing</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation-of-tree-growing"><span class="nav-number">1.1.</span> <span class="nav-text">Implementation of tree growing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS-amp-DFS-as-Tree-Growing"><span class="nav-number">1.2.</span> <span class="nav-text">BFS &amp; DFS as Tree Growing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nextEdge-for-BFS"><span class="nav-number">1.3.</span> <span class="nav-text">nextEdge for BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nextEdge-for-DFS"><span class="nav-number">1.4.</span> <span class="nav-text">nextEdge for DFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DFS"><span class="nav-number">2.</span> <span class="nav-text">DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-idea"><span class="nav-number">2.1.</span> <span class="nav-text">Basic idea</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Non-DFS-Tree-edges"><span class="nav-number">2.2.</span> <span class="nav-text">Non-DFS-Tree edges</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Recursive-implementation-of-DFS"><span class="nav-number">2.3.</span> <span class="nav-text">Recursive implementation of DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Algorithm"><span class="nav-number">2.3.1.</span> <span class="nav-text">Algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pseudo-code"><span class="nav-number">2.3.2.</span> <span class="nav-text">pseudo code</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-implementation"><span class="nav-number">2.3.3.</span> <span class="nav-text">Java implementation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stack-based-implantation-of-DFS"><span class="nav-number">2.3.4.</span> <span class="nav-text">Stack based implantation of DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparison-of-recursively-achieved-and-stack-based-algorithm"><span class="nav-number">2.3.5.</span> <span class="nav-text">Comparison of recursively achieved and stack-based algorithm</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Topological-sorting-DFS-application"><span class="nav-number">2.4.</span> <span class="nav-text">Topological sorting (DFS application)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DAGs"><span class="nav-number">2.4.1.</span> <span class="nav-text">DAGs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Theorem"><span class="nav-number">2.4.2.</span> <span class="nav-text">Theorem:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Topological-sorting-algorithm"><span class="nav-number">2.4.3.</span> <span class="nav-text">Topological sorting algorithm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Run-time-analysis"><span class="nav-number">2.4.4.</span> <span class="nav-text">Run time analysis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Applications"><span class="nav-number">2.4.5.</span> <span class="nav-text">Applications</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BFS"><span class="nav-number">3.</span> <span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Pseudocode"><span class="nav-number">3.1.</span> <span class="nav-text">Pseudocode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Finding-all-connected-components"><span class="nav-number">3.2.</span> <span class="nav-text">Finding all connected components</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bipartiteness"><span class="nav-number">3.2.1.</span> <span class="nav-text">Bipartiteness</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bipartite-Graph-Checker"><span class="nav-number">3.2.2.</span> <span class="nav-text">Bipartite Graph Checker</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Applications-1"><span class="nav-number">4.</span> <span class="nav-text">Applications</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Detecting-cycle"><span class="nav-number">4.1.</span> <span class="nav-text">Detecting cycle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q4-in-midterm-practice"><span class="nav-number">4.2.</span> <span class="nav-text">Q4 in midterm practice</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Answer"><span class="nav-number">4.2.1.</span> <span class="nav-text">Answer</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
