<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Welcome to my personal blogs">
    <meta name="author" content="Yuxuan Wu">
    
    <title>
        
            Dijkstra algorithm |
        
        Yuxuan Wu
    </title>
    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep coding, Keep hungry."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.3.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days age","week":"%s weeks age","month":"%s months age","year":"%s years age"};
  </script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Yuxuan Wu
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content normal-code-theme">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Dijkstra algorithm</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Yuxuan Wu</span>
                        <span class="level">Lv13</span>
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i> 2021-10-28 10:16:23
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/CMUAlgoNotes/">CMUAlgoNotes</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/graph/">graph</a>
                    </li>
                
                    <li>
                        | <a href="/tags/Dijkstra/">Dijkstra</a>
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i> <span>2.5k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i> <span>14 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="Helper-resources"><a href="#Helper-resources" class="headerlink" title="Helper resources"></a>Helper resources</h1><p><a class="link" target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-in-java-using-priorityqueue/">https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-in-java-using-priorityqueue/<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link" target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/">https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/<i class="fas fa-external-link-alt"></i></a> 最像课上教的 (heap based Dijkstra algorithm)</p>
<h1 id="Dijkstra’s-Shortest-path-problem"><a href="#Dijkstra’s-Shortest-path-problem" class="headerlink" title="Dijkstra’s Shortest path problem"></a>Dijkstra’s Shortest path problem</h1><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211027195039.png" alt="image-20211027195037847"></p>
<h2 id="Which-kind-of-problem-to-solve"><a href="#Which-kind-of-problem-to-solve" class="headerlink" title="Which kind of problem to solve"></a>Which kind of problem to solve</h2><p>Given a graph and a source vertex in the graph, find the shortest paths from the source to all vertices in the given graph.</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211027195102.png" alt="image-20211027195101089"></p>
<h2 id="Shortest-Paths-and-BFS"><a href="#Shortest-Paths-and-BFS" class="headerlink" title="Shortest Paths and BFS"></a>Shortest Paths and BFS</h2><ol>
<li>BFS is an algorithm for finding shortest (link-distance) paths from a single source vertex to all other vertices</li>
<li>BFS processes vertices in increasing order of their distance from the root vertex</li>
</ol>
<h2 id="Tree-growing-again"><a href="#Tree-growing-again" class="headerlink" title="Tree growing again"></a>Tree growing again</h2><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211027200733.png" alt="image-20211027200731698"></p>
<h3 id="nextEdge-for-shortest-path"><a href="#nextEdge-for-shortest-path" class="headerlink" title="nextEdge for shortest path"></a>nextEdge for shortest path</h3><ol>
<li>Let u be some node that we have already visited (it will be in S)</li>
<li>Let <code>d(u)</code> be the length of the s - u path found for node u <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.09ex" xmlns="http://www.w3.org/2000/svg" width="1.509ex" height="1.312ex" role="img" focusable="false" viewBox="0 -540 667 580"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g></g></g></svg></mjx-container> s </li>
<li><code>nextEdge:</code> return the frontier edge (u,v) for which d(u) + length(u,v) is minimized</li>
<li>The <code>d(u)</code> term is the difference from Prim’s algorithm</li>
</ol>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="Heap-pseudocode"><a href="#Heap-pseudocode" class="headerlink" title="Heap pseudocode"></a>Heap pseudocode</h2><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211028095857.png" alt="image-20211028095855331"></p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output:"></a>Output:</h3><p>Dijkstra’s algorithm would output a list of parent-child relationships (array p) and a list of source-to-node distance (array d)</p>
<h2 id="Pseudocode-from-wiki"><a href="#Pseudocode-from-wiki" class="headerlink" title="Pseudocode from wiki"></a>Pseudocode from wiki</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1) Initialize distances of all vertices as infinite.</span><br><span class="line"></span><br><span class="line">2) Create an empty set.  Every item of set is a pair</span><br><span class="line">  (weight, vertex). Weight (or distance) is used used</span><br><span class="line">  as first item  of pair as first item is by default </span><br><span class="line">  used to compare two pairs.</span><br><span class="line"></span><br><span class="line">3) Insert source vertex into the set and make its</span><br><span class="line">   distance as 0.</span><br><span class="line"></span><br><span class="line">4) While Set doesn't become empty, do following</span><br><span class="line">    a) Extract minimum distance vertex from Set. </span><br><span class="line">       Let the extracted vertex be u.</span><br><span class="line">    b) Loop through all adjacent of u and do </span><br><span class="line">       following for every vertex v.</span><br><span class="line"></span><br><span class="line">           // If there is a shorter path to v</span><br><span class="line">           // through u. </span><br><span class="line">           If dist[v] &gt; dist[u] + weight(u, v)</span><br><span class="line"></span><br><span class="line">               (i) Update distance of v, i.e., do</span><br><span class="line">                     dist[v] = dist[u] + weight(u, v)</span><br><span class="line">               (i) If v is in set, update its distance</span><br><span class="line">                   in set by removing it first, then</span><br><span class="line">                   inserting with new distance</span><br><span class="line">               (ii) If v is not in set, then insert</span><br><span class="line">                    it in set with new distance</span><br><span class="line">               </span><br><span class="line">5) Print distance array dist[] to print all shortest</span><br><span class="line">   paths. </span><br></pre></td></tr></table></figure>


<p><code>Drawback:</code> while finding the shortest path as listed as follows as we need to find the least cost path by going through the whole cost array.</p>
<p>It can be applied to both directed and undirected graph. Here is why:</p>
<p>An <em>undirected</em> graph is basically the same as a <em>directed</em> graph with <strong>bidirectional</strong> connections (= two connections in opposite directions) between the connected nodes.</p>
<p>So you don’t really have to do anything to make it work for an undirected graph. You only need to know all of the nodes that can be reached from every given node through e.g. an <strong>adjacency list</strong>.</p>
<h2 id="Java-implementation"><a href="#Java-implementation" class="headerlink" title="Java implementation"></a>Java implementation</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.algorithm.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.linear.Queue;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.algorithm.priority.IndexMinPriorityQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraSP</span> </span>{</span><br><span class="line">    <span class="comment">//索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边</span></span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</span><br><span class="line">    <span class="comment">//索引代表顶点，值从顶点s到当前顶点的最短路径的总权重</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</span><br><span class="line">    <span class="comment">//存放树中顶点与非树中顶点之间的有效横切边</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinPriorityQueue&lt;Double&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DijkstraSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span></span>{</span><br><span class="line">        <span class="comment">//初始化edgeTo</span></span><br><span class="line">        <span class="keyword">this</span>.edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">        <span class="comment">//初始化distTo</span></span><br><span class="line">        <span class="keyword">this</span>.distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; distTo.length; i++) {</span><br><span class="line">            distTo[i] = Double.POSITIVE_INFINITY;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//初始化pq</span></span><br><span class="line">        <span class="keyword">this</span>.pq = <span class="keyword">new</span> IndexMinPriorityQueue&lt;&gt;(G.V());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到图G中以顶点s为起点的最短路径树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认让顶点s进入到最短路径树中</span></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">        pq.insert(s,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历pq</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()){</span><br><span class="line">            relax(G,pq.delMin());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//松弛图G中的顶点v</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge edge : G.adj(v)) {</span><br><span class="line">            <span class="comment">//获取到该边的终点w</span></span><br><span class="line">            <span class="keyword">int</span> w = edge.to();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过松弛技术，判断从起点s到顶点w的最短路径是否需要先从顶点s到顶点v，然后再由顶点v到顶点w</span></span><br><span class="line">            <span class="keyword">if</span> (distTo(v)+edge.weight()&lt;distTo(w)){</span><br><span class="line">                distTo[w] = distTo[v]+edge.weight();</span><br><span class="line">                edgeTo[w] = edge;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断pq中是否已经存在顶点w，如果存在，则更新权重，如果不存在，则直接添加</span></span><br><span class="line">                <span class="keyword">if</span> (pq.contains(w)){</span><br><span class="line">                    pq.changeItem(w,distTo(w));</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                    pq.insert(w,distTo(w));</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取从顶点s到顶点v的最短路径的总权重</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断从顶点s到顶点v是否可达</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> distTo[v]&lt;Double.POSITIVE_INFINITY;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询从起点s到顶点v的最短路径中所有的边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">        <span class="comment">//判断从顶点s到顶点v是否可达，如果不可达，直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列对象</span></span><br><span class="line">        Queue&lt;DirectedEdge&gt; allEdges = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">            DirectedEdge e = edgeTo[v];</span><br><span class="line">            <span class="keyword">if</span> (e==<span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            allEdges.enqueue(e);</span><br><span class="line"></span><br><span class="line">            v = e.from();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> allEdges;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<p><code>Array based</code></p>
<p>Algorithm<br><strong>1)</strong> Create a set <em>sptSet</em> (shortest path tree set) that keeps track of vertices included in the shortest-path tree, i.e., whose minimum distance from the source is calculated and finalized. Initially, this set is empty.<br><strong>2)</strong> Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value as 0 for the source vertex so that it is picked first.<br><strong>3)</strong> While <em>sptSet</em> doesn’t include all vertices<br>….<strong>a)</strong> Pick a vertex u which is not there in <em>sptSet</em> and has a minimum distance value.<br>….<strong>b)</strong> Include u to <em>sptSet</em>.<br>….<strong>c)</strong> Update distance value of all adjacent vertices of u. To update the distance values, iterate through all adjacent vertices. For every adjacent vertex v, if the sum of distance value of u (from source) and weight of edge u-v, is less than the distance value of v, then update the distance value of v. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A Java program for Dijkstra's single source shortest path algorithm.</span></span><br><span class="line"><span class="comment">// The program is for adjacency matrix representation of the graph</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span> </span>{</span><br><span class="line">    <span class="comment">// A utility function to find the vertex with minimum distance value,</span></span><br><span class="line">    <span class="comment">// from the set of vertices not yet included in shortest path tree</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> V = <span class="number">9</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">int</span> dist[], Boolean sptSet[])</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// Initialize min value</span></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, min_index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">            <span class="keyword">if</span> (sptSet[v] == <span class="keyword">false</span> &amp;&amp; dist[v] &lt;= min) {</span><br><span class="line">                min = dist[v];</span><br><span class="line">                min_index = v;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_index;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A utility function to print the constructed distance array</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printSolution</span><span class="params">(<span class="keyword">int</span> dist[])</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        System.out.println(<span class="string">"Vertex \t\t Distance from Source"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">            System.out.println(i + <span class="string">" \t\t "</span> + dist[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function that implements Dijkstra's single source shortest path</span></span><br><span class="line">    <span class="comment">// algorithm for a graph represented using adjacency matrix</span></span><br><span class="line">    <span class="comment">// representation</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> graph[][], <span class="keyword">int</span> src)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> dist[] = <span class="keyword">new</span> <span class="keyword">int</span>[V]; <span class="comment">// The output array. dist[i] will hold</span></span><br><span class="line">        <span class="comment">// the shortest distance from src to i</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// sptSet[i] will true if vertex i is included in shortest</span></span><br><span class="line">        <span class="comment">// path tree or shortest distance from src to i is finalized</span></span><br><span class="line">        Boolean sptSet[] = <span class="keyword">new</span> Boolean[V];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize all distances as INFINITE and stpSet[] as false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) {</span><br><span class="line">            dist[i] = Integer.MAX_VALUE;</span><br><span class="line">            sptSet[i] = <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Distance of source vertex from itself is always 0</span></span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find shortest path for all vertices</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; V - <span class="number">1</span>; count++) {</span><br><span class="line">            <span class="comment">// Pick the minimum distance vertex from the set of vertices</span></span><br><span class="line">            <span class="comment">// not yet processed. u is always equal to src in first</span></span><br><span class="line">            <span class="comment">// iteration.</span></span><br><span class="line">            <span class="keyword">int</span> u = minDistance(dist, sptSet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Mark the picked vertex as processed</span></span><br><span class="line">            sptSet[u] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update dist value of the adjacent vertices of the</span></span><br><span class="line">            <span class="comment">// picked vertex.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Update dist[v] only if is not in sptSet, there is an</span></span><br><span class="line">                <span class="comment">// edge from u to v, and total weight of path from src to</span></span><br><span class="line">                <span class="comment">// v through u is smaller than current value of dist[v]</span></span><br><span class="line">                <span class="keyword">if</span> (!sptSet[v] &amp;&amp; graph[u][v] != <span class="number">0</span> &amp;&amp; dist[u] != Integer.MAX_VALUE &amp;&amp; dist[u] + graph[u][v] &lt; dist[v])</span><br><span class="line">                    dist[v] = dist[u] + graph[u][v];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print the constructed distance array</span></span><br><span class="line">        printSolution(dist);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">/* Let us create the example graph discussed above */</span></span><br><span class="line">        <span class="keyword">int</span> graph[][] = <span class="keyword">new</span> <span class="keyword">int</span>[][] { { <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span> },</span><br><span class="line">                { <span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">0</span> },</span><br><span class="line">                { <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span> },</span><br><span class="line">                { <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> },</span><br><span class="line">                { <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> },</span><br><span class="line">                { <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span> },</span><br><span class="line">                { <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span> },</span><br><span class="line">                { <span class="number">8</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span> },</span><br><span class="line">                { <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span> } };</span><br><span class="line">        ShortestPath t = <span class="keyword">new</span> ShortestPath();</span><br><span class="line">        t.dijkstra(graph, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// This code is contributed by Aakash Hasija</span></span><br></pre></td></tr></table></figure>
<p><code>Original figures</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031170217.jpg" alt="img"></p>
<p><code>Results</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031170147.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vertex 		 Distance from Source</span><br><span class="line">0 		 0</span><br><span class="line">1 		 4</span><br><span class="line">2 		 12</span><br><span class="line">3 		 19</span><br><span class="line">4 		 21</span><br><span class="line">5 		 11</span><br><span class="line">6 		 9</span><br><span class="line">7 		 8</span><br><span class="line">8 		 14</span><br></pre></td></tr></table></figure>


<h1 id="Run-time-analysis"><a href="#Run-time-analysis" class="headerlink" title="Run time analysis"></a>Run time analysis</h1><ol>
<li>Every edge is processed in the <code>for</code> loop at most once</li>
<li>In response to that processing, we may either<ol>
<li>Do nothing</li>
<li>Insert an item into the heap of at most V items; <code>O(log|V|)</code></li>
<li>Reduce the key of an item in a heap of at most <code>|V|</code> items; <code>O(log|V|)</code></li>
</ol>
</li>
</ol>
<blockquote>
<p>Total Time complexity : <code>O(E*log(V))</code></p>
</blockquote>
<h1 id="Comparison-with-BellmanFord"><a href="#Comparison-with-BellmanFord" class="headerlink" title="Comparison with BellmanFord"></a>Comparison with BellmanFord</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Dijkstra only process the minimum edge, while Bellman-ford process every edge. This makes Bell-man ford slower, but it can handle negative edges</p>
<h2 id="Consider-the-graph-shown-below-with-the-source-as-Vertex-A-First-try-running-Dijkstra’s-algorithm-yourself-on-it"><a href="#Consider-the-graph-shown-below-with-the-source-as-Vertex-A-First-try-running-Dijkstra’s-algorithm-yourself-on-it" class="headerlink" title="Consider the graph shown below with the source as Vertex A. First try running Dijkstra’s algorithm yourself on it."></a>Consider the graph shown below with the source as Vertex A. First try running Dijkstra’s algorithm yourself on it.</h2><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165020.png" alt="enter image description here"></p>
<p>When I refer to Dijkstra’s algorithm in my explanation I will be talking about the Dijkstra’s Algorithm as implemented below,</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165016.png" alt="Dijkstra’s algorithm"></p>
<p>So starting out the <strong>values</strong> (<em>the distance from the source to the vertex</em>) initially assigned to each vertex are,</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165044.png" alt="initialization"></p>
<p>We first extract the vertex in <strong>Q = [A,B,C]</strong> which has smallest value, i.e. A, after which <strong>Q = [B, C]</strong>. Note A has a directed edge to B and C, also both of them are in Q, therefore we update both of those values,</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165052.png" alt="first iteration"></p>
<p>Now we extract C as (2&lt;5), now <strong>Q = [B]</strong>. Note that C is connected to nothing, so <code>line16</code> loop doesn’t run.</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165109.png" alt="second iteration"></p>
<p>Finally we extract B, after which <a target="_blank" rel="noopener" href="https://i.stack.imgur.com/s2ono.png"><img src="https://i.stack.imgur.com/s2ono.png" alt="Q is Phi"></a>. Note B has a directed edge to C but C isn’t present in Q therefore we again don’t enter the for loop in <code>line16</code>,</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165114.png" alt="3rd?"></p>
<p>So we end up with the distances as</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165118.png" alt="no change guys"></p>
<p>Note how this is wrong as the shortest distance from A to C is 5 + -10 = -5, when you go <img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165128.png" alt="a to b to c">.</p>
<p><strong>So for this graph Dijkstra’s Algorithm wrongly computes the distance from A to C.</strong></p>
<p>This happens because Dijkstra’s Algorithm does not try to find a shorter path to vertices which are <em>already extracted from Q</em>.</p>
<p>What the <code>line16</code> loop is doing is taking the vertex <strong>u</strong> and saying <em>“hey looks like we can go to <strong>v</strong> from source via <strong>u</strong>, is that (alt or alternative) distance any better than the current <strong>dist[v]</strong> we got? If so lets update <strong>dist[v]</strong>“</em></p>
<p>Note that in <code>line16</code> they check all neighbors <strong>v</strong> (i.e. a directed edge exists from <strong>u to v</strong>), of <strong>u</strong> which are <strong>still in Q</strong>. In <code>line14</code> they remove visited notes from Q. So if <strong>x</strong> is a visited neighbour of <strong>u</strong>, the path <img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165139.latex" alt="source to u to x"> is <em>not even considered</em> as a possible shorter way from source to <strong>v</strong>.</p>
<p>In our example above, C was a visited neighbour of B, thus the path <img src="https://latex.codecogs.com/gif.latex?A&space;%5Cto&space;B&space;%5Cto&space;C" alt="[A to B to C](https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165144.latex)"> was not considered, leaving the current shortest path <img src="https://latex.codecogs.com/gif.latex?A&space;%5Cto&space;C" alt="[A to C](https://cdn.jsdelivr.net/gh/imgstore/typora/20211031165148.latex)"> unchanged.</p>
<p>This is actually useful <em>if the edge weights are all positive numbers</em>, because then we wouldn’t waste our time considering paths that <strong>can’t be</strong> shorter.</p>
<p>So I say that when running this algorithm if <strong>x</strong> is extracted from Q before <strong>y</strong>, then its not possible to find a path - <a target="_blank" rel="noopener" href="https://i.stack.imgur.com/OjAzQ.png"><img src="https://i.stack.imgur.com/OjAzQ.png" alt="not possible"></a> which is shorter. Let me explain this with an example,</p>
<p>As <strong>y</strong> has just been extracted and <strong>x</strong> had been extracted before itself, then <strong>dist[y] &gt; dist[x]</strong> because otherwise <strong>y</strong> would have been extracted before <strong>x</strong>. (<code>line 13</code> min distance first)</p>
<p>And as we already <em>assumed</em> that the edge weights are positive, i.e. <strong>length(x,y)&gt;0</strong>. So the alternative distance (alt) via <strong>y</strong> is always sure to be greater, i.e. <strong>dist[y] + length(x,y)&gt; dist[x]</strong>. So the value of <strong>dist[x]</strong> would not have been updated even if <strong>y</strong> was considered as a path to <strong>x</strong>, thus we conclude that it makes sense to only consider neighbors of <strong>y</strong> which are still in Q (note comment in <code>line16</code>)</p>
<p>But this thing hinges on our assumption of positive edge length, if <strong>length(u,v)&lt;0</strong> then depending on how negative that edge is we might replace the <strong>dist[x]</strong> after the comparison in <code>line18</code>.</p>
<blockquote>
<p>So any <strong>dist[x]</strong> calculation we make will be incorrect if <strong>x</strong> is removed before all vertices <strong>v</strong> - such that <strong>x</strong> is a neighbour of <strong>v</strong> with negative edge connecting them - is removed.</p>
</blockquote>
<p>Because each of those <strong>v</strong> vertices is the second last vertex on a potential “better” path from source to <strong>x</strong>, which is discarded by Dijkstra’s algorithm.</p>
<p>So in the example I gave above, the mistake was because C was removed before B was removed. While that C was a neighbour of B with a negative edge!</p>
<p>Just to clarify, B and C are A’s neighbours. B has a single neighbour C and C has no neighbours. length(a,b) is the edge length between the vertices a and b.</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：Dijkstra algorithm</li>
        <li>Post author：Yuxuan Wu</li>
        <li>Create time：2021-10-28 10:16:23</li>
        <li>
            Post link：yuxuanwu17.github.io2021/10/28/2021-10-06-Dijkstra-algorithm/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/10/28/2021-10-28-A-algorithm/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">A* algorithm</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/10/25/2021-10-25-MST-algo-notes/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">MST algo notes</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span> -
            
            2021 <i class="fas fa-heart icon-animate"></i> <a href="/">Yuxuan Wu</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count <span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a> | Theme <a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.3.1</a>
        </div>
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Helper-resources"><span class="nav-number">1.</span> <span class="nav-text">Helper resources</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dijkstra%E2%80%99s-Shortest-path-problem"><span class="nav-number">2.</span> <span class="nav-text">Dijkstra’s Shortest path problem</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Which-kind-of-problem-to-solve"><span class="nav-number">2.1.</span> <span class="nav-text">Which kind of problem to solve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shortest-Paths-and-BFS"><span class="nav-number">2.2.</span> <span class="nav-text">Shortest Paths and BFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tree-growing-again"><span class="nav-number">2.3.</span> <span class="nav-text">Tree growing again</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nextEdge-for-shortest-path"><span class="nav-number">2.3.1.</span> <span class="nav-text">nextEdge for shortest path</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Implementation"><span class="nav-number">3.</span> <span class="nav-text">Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap-pseudocode"><span class="nav-number">3.1.</span> <span class="nav-text">Heap pseudocode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Output"><span class="nav-number">3.1.1.</span> <span class="nav-text">Output:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pseudocode-from-wiki"><span class="nav-number">3.2.</span> <span class="nav-text">Pseudocode from wiki</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-implementation"><span class="nav-number">3.3.</span> <span class="nav-text">Java implementation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Run-time-analysis"><span class="nav-number">4.</span> <span class="nav-text">Run time analysis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Comparison-with-BellmanFord"><span class="nav-number">5.</span> <span class="nav-text">Comparison with BellmanFord</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Summary"><span class="nav-number">5.1.</span> <span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Consider-the-graph-shown-below-with-the-source-as-Vertex-A-First-try-running-Dijkstra%E2%80%99s-algorithm-yourself-on-it"><span class="nav-number">5.2.</span> <span class="nav-text">Consider the graph shown below with the source as Vertex A. First try running Dijkstra’s algorithm yourself on it.</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
