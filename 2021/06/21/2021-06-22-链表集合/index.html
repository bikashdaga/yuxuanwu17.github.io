<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Welcome to my personal blogs">
    <meta name="author" content="Yuxuan Wu">
    
    <title>
        
            链表集合 |
        
        Yuxuan Wu
    </title>
    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep coding, Keep hungry."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.3.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days age","week":"%s weeks age","month":"%s months age","year":"%s years age"};
  </script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Yuxuan Wu
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content normal-code-theme">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">链表集合</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Yuxuan Wu</span>
                        <span class="level">Lv13</span>
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i> 2021-06-21 21:18:13
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/Algorithms/">Algorithms</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/leetcode/">leetcode</a>
                    </li>
                
                    <li>
                        | <a href="/tags/LinkedList/">LinkedList</a>
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i> <span>6.8k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i> <span>29 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>设计链表的实现。您可以选择使用单链表或双链表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210622092205.png" alt="img"></p>
<ul>
<li>单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。</li>
<li>双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</li>
</ul>
<p>在链表类中实现这些功能：</p>
<p><code>get(index)</code>：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br><code>addAtHead(val)</code>：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br><code>addAtTail(val)</code>：将值为 val 的节点追加到链表的最后一个元素。<br><code>addAtIndex(index,val)</code>：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br><code>deleteAtIndex(index)</code>：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<h3 id="单链表结点的实现"><a href="#单链表结点的实现" class="headerlink" title="单链表结点的实现"></a>单链表结点的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglyListNode</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    SinglyListNode next;</span><br><span class="line">    SinglyListNode(<span class="keyword">int</span> x) { </span><br><span class="line">      <span class="keyword">this</span>.val = x; </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>一个值</li>
<li>一个引用字段</li>
</ul>
<h3 id="Leetcode-上的测试代码"><a href="#Leetcode-上的测试代码" class="headerlink" title="Leetcode 上的测试代码"></a>Leetcode 上的测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> linear;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) {</span><br><span class="line">        <span class="keyword">this</span>.val = x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表节点的构造函数</span></span><br><span class="line">    <span class="comment">// 使用arr为参数，创建一个链表，当前的ListNode为链表头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span>[] arr)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"arr can not be empty"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.val = arr[<span class="number">0</span>];</span><br><span class="line">        ListNode cur = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) {</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以当前节点为头节点的链表信息字符串 方便查看</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ListNode cur = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            res.append(cur.val + <span class="string">"-&gt;"</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        res.append(<span class="string">"NULL"</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>创建ListNode结点类（核心一个存value，一个存引用地址）</li>
<li>构造参数，以接受不同的输入 （这里核心是需要接收Array的格式，然后将值转换成链表）</li>
<li>重写toString 的方法，以适合打印print</li>
</ul>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2-&gt;4-&gt;3-&gt;NULL</span><br><span class="line"></span><br><span class="line">5-&gt;6-&gt;4-&gt;NULL</span><br><span class="line"></span><br><span class="line">7-&gt;0-&gt;8-&gt;NULL</span><br></pre></td></tr></table></figure>


<h3 id="单链表实现"><a href="#单链表实现" class="headerlink" title="单链表实现"></a>单链表实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="keyword">int</span> val) {</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    Node head; </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(index &lt;<span class="number">0</span> || index &gt;= size|| head == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        Node temp = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;index; i++){</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        Node node = <span class="keyword">new</span> Node (val);</span><br><span class="line">        node.next= <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">this</span>.head = node;</span><br><span class="line">        size ++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (size==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> Node (val);</span><br><span class="line">            head.next= <span class="keyword">null</span>;</span><br><span class="line">            size++;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            Node temp = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>){</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            }</span><br><span class="line">            Node tail = <span class="keyword">new</span> Node(val);</span><br><span class="line">            tail.next =<span class="keyword">null</span>;</span><br><span class="line">            temp.next =tail;</span><br><span class="line">            size++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index&gt;<span class="keyword">this</span>.size){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index&lt;=<span class="number">0</span>){</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index==<span class="keyword">this</span>.size){</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node temp = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;index-<span class="number">1</span>;i++){</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Node insertNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        insertNode.next = temp.next;</span><br><span class="line">        temp.next = insertNode;</span><br><span class="line">        size ++;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.size) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">if</span> (size != <span class="number">1</span>) {</span><br><span class="line">                Node temp = <span class="keyword">this</span>.head.next;</span><br><span class="line">                <span class="keyword">this</span>.head =temp;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Node temp = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++) {</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        }</span><br><span class="line">        Node deleteNode = temp.next;</span><br><span class="line">        temp.next = deleteNode.next;</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<p><strong>Reference:</strong><br>链接：<a class="link" target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/linked-list/jy291/">https://leetcode-cn.com/leetbook/read/linked-list/jy291/<i class="fas fa-external-link-alt"></i></a><br>来源：力扣（LeetCode）</p>
<h1 id="LeetCode-算法实战"><a href="#LeetCode-算法实战" class="headerlink" title="LeetCode 算法实战"></a>LeetCode 算法实战</h1><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><p>难度中等1424收藏分享切换为英文接收动态反馈</p>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210629190726.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>


<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<hr>
<h3 id="方法1：-计算链表的长度"><a href="#方法1：-计算链表的长度" class="headerlink" title="方法1： 计算链表的长度"></a>方法1： 计算链表的长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">// 1. 定义dummyNode,便于后来的插入和操作，返回一整条链表</span></span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 先算出链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = getNodeLength(head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 定义current结点</span></span><br><span class="line">        ListNode curr = dummyNode;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 循环结点到待删除节点的前一个</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr.next!=<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span> (i == length-n) <span class="keyword">break</span>;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">  			<span class="comment">// 5. 执行删除操作</span></span><br><span class="line">        curr.next = curr.next.next;</span><br><span class="line">  </span><br><span class="line">  			<span class="comment">// 6. 返回dummyNode 那条链除了第一个dummyNode的</span></span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNodeLength</span><span class="params">(ListNode node)</span></span>{</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">// 7. 注意这个node！=null 而不是node.next</span></span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>){</span><br><span class="line">                n++;</span><br><span class="line">                node = node.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        }</span><br></pre></td></tr></table></figure>


<h3 id="方法2：双指针"><a href="#方法2：双指针" class="headerlink" title="方法2：双指针"></a>方法2：双指针</h3><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210629192422.png" alt="p3"></p>
<p><strong>哑结点（dummy head）:</strong> </p>
<ul>
<li>不存储数据，这里使用的目的是保证当第一个指针走到null的时候，第二个指针正好走到了待删除结点的前一个结点，这样就可以轻松的删除，直接<code>second = second.next.next</code>循环到下一个去</li>
<li>可以用来最后指定链表，否则没法最后指定返回所有的链表<ul>
<li>因为ListNode = ListNode.next; 所以理论上这个是会变得！</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义dummy head</span></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 定义firstNode 从head出发</span></span><br><span class="line">    ListNode firstNode = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 定义secondNode 在dummy head</span></span><br><span class="line">    ListNode secondNode = dummyHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 循环n下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        firstNode = firstNode.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. secondNode 和firstNode 同时出发； 直到firstNode == null</span></span><br><span class="line">    <span class="keyword">while</span> (firstNode != <span class="keyword">null</span>) {</span><br><span class="line">        firstNode = firstNode.next;</span><br><span class="line">        secondNode = secondNode.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 完成删除操作</span></span><br><span class="line">    secondNode.next = secondNode.next.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 定义一个新的完整的链表返回</span></span><br><span class="line">    ListNode ans = dummyHead;</span><br><span class="line">    ans = dummyHead.next;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210623101002.png"></p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<p>示例 1：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210623101015.png" alt="img"></p>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>示例 2：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210623101025.png" alt="img"></p>
<p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br>示例 3：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210623101034.png" alt="img"></p>
<p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。</p>
<p>提示：</p>
<p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>0 &lt;= m, n &lt;= 3 * 104<br>1 &lt;= Node.val &lt;= 105<br>0 &lt;= skipA &lt;= m<br>0 &lt;= skipB &lt;= n<br>如果 listA 和 listB 没有交点，intersectVal 为 0<br>如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]</p>
<h3 id="注意考虑"><a href="#注意考虑" class="headerlink" title="注意考虑"></a>注意考虑</h3><p>注意以下的情况是不会出现的</p>
<p>但是不会出现以下相交的情况，因为每个节点只有一个 next 指针，也就只能有一个后继节点，而以下示例中节点 c 有两个后继节点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2       d1 → d2</span><br><span class="line">                    ↘  ↗</span><br><span class="line">                      c</span><br><span class="line">                    ↗  ↘</span><br><span class="line">B:    b1 → b2 → b3        e1 → e2</span><br></pre></td></tr></table></figure>


<h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) {</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>{</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)</span></span><br><span class="line"><span class="comment">        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="comment">// 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头</span></span><br><span class="line">      <span class="comment">//而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null</span></span><br><span class="line">      <span class="comment">// 终止条件就是null==null</span></span><br><span class="line">        <span class="keyword">while</span>(pA != pB) {</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210623094833.png" alt="相交链表.png"></p>
<p>一图胜千言，看图你就明白了</p>
<p>空间复杂度 O(1)O(1) 时间复杂度为 O(n)O(n)</p>
<p>这里使用图解的方式，解释比较巧妙的一种实现。</p>
<p>根据题目意思<br>如果两个链表相交，那么相交点之后的长度是相同的</p>
<p>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。<br>为此，我们必须消除两个链表的长度差</p>
<p>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历<br>如果 pA 到了末尾，则 pA = headB 继续遍历<br>如果 pB 到了末尾，则 pB = headA 继续遍历<br>比较长的链表指针指向较短链表head时，长度差就消除了<br>如此，只需要将最短链表遍历两次即可找到位置</p>
<p>作者：reals<br>链接：<a class="link" target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/<i class="fas fa-external-link-alt"></i></a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<blockquote>
<p>走到尽头见不到你，于是走过你来时的路，等到相遇时才发现，你也走过我来时的路。</p>
<p>可以理解成两个人速度一致， 走过的路程一致。那么肯定会同一个时间点到达终点。如果到达终点的最后一段路两人都走的话，那么这段路上俩人肯定是肩并肩手牵手的。 nb</p>
</blockquote>
<h2 id="141-环形链表I"><a href="#141-环形链表I" class="headerlink" title="141.环形链表I"></a>141.环形链表I</h2><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210622193746.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210622193821.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<h3 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCircle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    <span class="comment">// 这里考虑的是只有头结点和头结点为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) {</span><br><span class="line">        <span class="comment">// 这里需要保证fast.next 仍然有下一个结点，所以需要进行判断</span></span><br><span class="line">      	<span class="comment">// 循环断开的条件是fast已经到头了，为null</span></span><br><span class="line">      	<span class="comment">// 因为假如没有loop，他一定会走到头，</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next== <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>双指针问题，一快一慢，如果重合则会有环</p>
<ul>
<li>注意这里是快慢指针开始位置不同</li>
</ul>
<blockquote>
<p>细节</p>
</blockquote>
<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>
<blockquote>
<p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head (就是fast = slow = head)，那么 while 循环就不会执行。这种情况会将无环情况错误识别成有环的情况</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">[1,2] -1</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">预期结果：</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure>


<blockquote>
<p>因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</p>
</blockquote>
<p>作者：LeetCode-Solution<br>链接：<a class="link" target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/">https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode-solution/<i class="fas fa-external-link-alt"></i></a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            }   <span class="keyword">catch</span> (Exception e){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (slow == fast){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>
<ul>
<li>注意这里双指针的起始位置是相同的</li>
<li>如果位置不同，需要像方法一一样判断是否存在空指针问题</li>
</ul>
<h3 id="方法3-HashSet"><a href="#方法3-HashSet" class="headerlink" title="方法3 HashSet"></a>方法3 HashSet</h3><ul>
<li>通过判断add的时候是否可以加入来返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    HashSet&lt;ListNode&gt; hashset = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(!hashset.add(head)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        head =head.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>
<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>
</blockquote>
<h2 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h2><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210622193831.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>


<blockquote>
<p>注意这里找到的其实是环结点</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210622193922.jpg" alt="1623750459597.jpg"></p>
<pre><code>    //下面开始找环的入口节点  
    //刚才的循环 慢指针走了a + b (a是从开始到入口节点) 假设等于cnt
    //          快指针走了 a + b + c + b (b + c = 环)，应该等于2 * cnt
    //推导出 a = c，所以把慢指针再放到头节点，下一次快慢指针相遇的节点即环的入口节点</code></pre>
<h3 id="方法1-2"><a href="#方法1-2" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) {</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//如果满足下面的条件，说明无环</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面开始找环的入口节点</span></span><br><span class="line">    <span class="comment">//刚才的循环 慢指针走了a + b (a是从开始到入口节点) 假设等于cnt</span></span><br><span class="line">    <span class="comment">//          快指针走了 a + b + c + b (b + c = 环)，应该等于2 * cnt</span></span><br><span class="line">    <span class="comment">//推导出 a = c，所以把慢指针再放到头节点，下一次快慢指针相遇的节点即环的入口节点</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) {</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="comment">// 先判断是否有环，找到环的入口(双指针)</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            }<span class="keyword">catch</span>(Exception e){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (slow == fast){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断无环的条件 (fast==null||fast.next==null)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一个指针放到开头，然后让慢指针继续走，下次相遇的地方就是环入口</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>






<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素<i class="fas fa-external-link-alt"></i></a></h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210811131922.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>


<h3 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h3><p>来看第一种操作：直接使用原来的链表来进行移除。</p>
<blockquote>
<p>此时遇到的问题就是头列表无法删除</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210811190846.png" alt="Image"></p>
<p>移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。</p>
<p>所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210811190853.png" alt="Image"></p>
<p>依然别忘将原头结点从内存中删掉。<img src="https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv7ueUia7WA5qehqAia2qrKPzcAYsrPwfrL5a8QtCBA16FmvtmtDGOMqZsHVkviamaXVJoiaz1Hwrx2UCw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>这样移除了一个头结点，是不是发现，在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。</p>
<p><code>所以推荐使用虚拟节点,来满足对头节点的操作</code></p>
<p>那么可不可以 以一种统一的逻辑来移除 链表的节点呢。</p>
<p>其实<strong>可以设置一个虚拟头结点</strong>，这样原链表的所有节点就都可以按照统一的方式进行移除了。</p>
<p>来看看如何设置一个虚拟头。依然还是在这个链表中，移除元素1。</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210811204947.png" alt="Image"></p>
<p>这里来给链表添加一个虚拟头结点为新的头结点，此时要移除这个旧头结点元素1。</p>
<p>这样是不是就可以使用和移除链表其他节点的方式统一了呢？</p>
<p>来看一下，如何移除元素1 呢，还是熟悉的方式，然后从内存中删除元素1。</p>
<p>最后呢在题目中，return 头结点的时候，别忘了 <code>return dummyNode-&gt;next;</code>， 这才是新的头结点</p>
<blockquote>
<p>链表的一大问题就是操作当前节点必须要找前一个节点才能操作。这就造成了，头结点的尴尬，因为头结点没有前一个节点了。</p>
<p><strong>每次对应头结点的情况都要单独处理，所以使用虚拟头结点的技巧，就可以解决这个问题</strong>。</p>
</blockquote>
<p>同时需要一个curr节点来完成遍历的操作，所以需要三个node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveElements</span> </span>{</span><br><span class="line">    <span class="comment">//    int[] num1 = {1, 2, 6, 3, 4, 5, 6};</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode curr = dummyHead; <span class="comment">// 如果这里改成head，则会导致在链表6，6，6的时候使第一个给保留下来,引入的dummyHead可以解决这个问题</span></span><br><span class="line">        <span class="keyword">while</span> (curr.next != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (curr.next.val == val) {</span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><blockquote>
<p>递归的核心解法其实就是不停的递归比较头节点的值是否相等（可以理解为压栈和弹栈）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    head.next = removeElements(head.next, val);</span><br><span class="line">    <span class="keyword">return</span> head.val == val? head.next: head;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210621215810.jpg" alt="img"></p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br><span class="line">示例 3：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>每个链表中的节点数在范围 [1, 100] 内</li>
<li>0 &lt;= Node.val &lt;= 9</li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a class="link" target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers<i class="fas fa-external-link-alt"></i></a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="方法1：-更加倾向于次方法"><a href="#方法1：-更加倾向于次方法" class="headerlink" title="方法1： 更加倾向于次方法"></a>方法1： 更加倾向于次方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">        <span class="comment">// 1. 定义头结点和尾结点;定义进位值</span></span><br><span class="line">        <span class="comment">// head 用来记录链表的头部，tail不断向后进行让链表变长</span></span><br><span class="line">        ListNode head = <span class="keyword">null</span>, tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 三元运算符来同时遍历l1,l2</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">int</span> num1 = l1 != <span class="keyword">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = l2 != <span class="keyword">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> perSum = num1 + num2 + carry;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="comment">// 3. 第一次循环，构建新的链表，用来处理第一个node的和并且赋值位val</span></span><br><span class="line">                <span class="comment">// 注意这里因为创建列表的早，所以head即是tail</span></span><br><span class="line">                head = tail = <span class="keyword">new</span> ListNode(perSum % <span class="number">10</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 4. 注意这里不是第一次第一次循环，是第二次循环以后</span></span><br><span class="line">                tail.next = <span class="keyword">new</span> ListNode(perSum % <span class="number">10</span>);</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 这里获得了进位的值，也用到了向下强转 (12/10 = 1 )</span></span><br><span class="line">            carry = perSum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6. 判断是否为最后一个结点, 保证循环</span></span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) {</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) {</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 如果链表遍历结束后进位符大于1，需要在答案链表后面附加一个结点，结点的值为carry</span></span><br><span class="line">            <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) {</span><br><span class="line">                tail.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure>


<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ListNode dummyHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span> ListNode tail = dummyHead;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers2</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// l1 &amp; l2 长度相同的部分</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">int</span> val = (l1.val + l2.val + carry) % <span class="number">10</span>;</span><br><span class="line">        carry = (l1.val + l2.val + carry) / <span class="number">10</span>;</span><br><span class="line">        appendNode(<span class="keyword">new</span> ListNode(val));</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// l1 比l2 长</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">int</span> val = (l1.val + <span class="number">0</span> + carry) % <span class="number">10</span>;</span><br><span class="line">        carry = (l1.val + carry) / <span class="number">10</span>;</span><br><span class="line">        appendNode(<span class="keyword">new</span> ListNode(val));</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// l2 比l1 长</span></span><br><span class="line">    <span class="keyword">while</span> (l2 != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">int</span> val = (<span class="number">0</span> + l2.val + carry) % <span class="number">10</span>;</span><br><span class="line">        carry = (l2.val + carry) / <span class="number">10</span>;</span><br><span class="line">        appendNode(<span class="keyword">new</span> ListNode(val));</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑最后一个进位符</span></span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) {</span><br><span class="line">        appendNode(<span class="keyword">new</span> ListNode(carry));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里是dummyHead.next</span></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendNode</span><span class="params">(ListNode node)</span> </span>{</span><br><span class="line">    tail.next = node;</span><br><span class="line">    tail = node;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<p>这里将appendNode分开，重新定义一个方法</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> linear.AddTwoNumber;</span><br><span class="line"><span class="keyword">import</span> linear.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 输入：l1 = [2,4,3], l2 = [5,6,4]</span></span><br><span class="line"><span class="comment"> * 输出：[7,0,8]</span></span><br><span class="line"><span class="comment"> * 解释：342 + 465 = 807.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTwoNumberTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">int</span>[] l1Array = {<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>};</span><br><span class="line">        <span class="keyword">int</span>[] l2Array = {<span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>};</span><br><span class="line">        ListNode l1 = <span class="keyword">new</span> ListNode(l1Array);</span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(l2Array);</span><br><span class="line">        System.out.println(l1);</span><br><span class="line">        System.out.println(l2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"================"</span>);</span><br><span class="line">        AddTwoNumber obj = <span class="keyword">new</span> AddTwoNumber();</span><br><span class="line">        ListNode results = obj.addTwoNumbers(l1, l2);</span><br><span class="line">        System.out.println(results);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<h2 id="19-删除链表的倒数第-N-个结点-1"><a href="#19-删除链表的倒数第-N-个结点-1" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h2><p>难度中等1424收藏分享切换为英文接收动态反馈</p>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210629190726.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>


<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<hr>
<h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210629192422.png" alt="p3"></p>
<p><strong>哑结点（dummy head）:</strong> </p>
<ul>
<li>不存储数据，这里使用的目的是保证当第一个指针走到null的时候，第二个指针正好走到了待删除结点的前一个结点，这样就可以轻松的删除，直接<code>second = second.next.next</code>循环到下一个去</li>
<li>可以用来最后指定链表，否则没法最后指定返回所有的链表<ul>
<li>因为ListNode = ListNode.next; 所以理论上这个是会变得！</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义dummy head</span></span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 定义firstNode 从head出发</span></span><br><span class="line">    ListNode firstNode = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 定义secondNode 在dummy head</span></span><br><span class="line">    ListNode secondNode = dummyHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 循环n下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        firstNode = firstNode.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. secondNode 和firstNode 同时出发； 直到firstNode == null</span></span><br><span class="line">    <span class="keyword">while</span> (firstNode != <span class="keyword">null</span>) {</span><br><span class="line">        firstNode = firstNode.next;</span><br><span class="line">        secondNode = secondNode.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 完成删除操作</span></span><br><span class="line">    secondNode.next = secondNode.next.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 定义一个新的完整的链表返回</span></span><br><span class="line">    ListNode ans = dummyHead;</span><br><span class="line">    ans = dummyHead.next;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<h3 id="方法二：-计算链表的长度"><a href="#方法二：-计算链表的长度" class="headerlink" title="方法二： 计算链表的长度"></a>方法二： 计算链表的长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">// 1. 定义dummyNode,便于后来的插入和操作，返回一整条链表</span></span><br><span class="line">        ListNode dummyNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>,head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 先算出链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = getNodeLength(head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 定义current结点</span></span><br><span class="line">        ListNode curr = dummyNode;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 循环结点到待删除节点的前一个</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr.next!=<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span> (i == length-n) <span class="keyword">break</span>;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">  			<span class="comment">// 5. 执行删除操作</span></span><br><span class="line">        curr.next = curr.next.next;</span><br><span class="line">  </span><br><span class="line">  			<span class="comment">// 6. 返回dummyNode 那条链除了第一个dummyNode的</span></span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNodeLength</span><span class="params">(ListNode node)</span></span>{</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">// 7. 注意这个node！=null 而不是node.next</span></span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>){</span><br><span class="line">                n++;</span><br><span class="line">                node = node.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        }</span><br></pre></td></tr></table></figure>

<h2 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a><a class="link" target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists<i class="fas fa-external-link-alt"></i></a></h2><p>Merge two sorted linked lists and return it as a <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210711144853.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 = [], l2 = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: l1 = [], l2 = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure>


<h3 id="方法1-迭代算法-："><a href="#方法1-迭代算法-：" class="headerlink" title="方法1(迭代算法)："></a>方法1(迭代算法)：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 注意不用考虑三种情况，相等的那种，因为只要保证一个不动，另一个也肯定不动</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists2</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">        <span class="comment">// 类似归并排序中的合并过程</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) {</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 任一为空，直接连接另一条链表</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) {</span><br><span class="line">            cur.next = l2;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            cur.next = l1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="方法2（ArrayList）"><a href="#方法2（ArrayList）" class="headerlink" title="方法2（ArrayList）:"></a>方法2（ArrayList）:</h3><blockquote>
<p>简单朴实的用arraylist来存储东西</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">    ArrayList&lt;Integer&gt; list1 = nodeToList(l1);</span><br><span class="line">    ArrayList&lt;Integer&gt; list2 = nodeToList(l2);</span><br><span class="line">    list1.addAll(list2);</span><br><span class="line"></span><br><span class="line">    Object[] array = list1.toArray();</span><br><span class="line">    Arrays.sort(array);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arrayToNode(array);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">nodeToList</span><span class="params">(ListNode node)</span> </span>{</span><br><span class="line">    ArrayList&lt;Integer&gt; arraylist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) {</span><br><span class="line">        arraylist.add(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arraylist;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">arrayToNode</span><span class="params">(Object[] array)</span> </span>{</span><br><span class="line">    ListNode listNode = <span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">    dummyHead.next = listNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) {</span><br><span class="line">        listNode.next = <span class="keyword">new</span> ListNode((Integer) array[i]);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next.next;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>


<p>方法一：递归<br>思路</p>
<p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/imgstore/typora/20210812124329.png" alt="image-20210812124329635"></p>
<p>也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。</p>
<p>算法</p>
<p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p>
<p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) {</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：O(n + m)O(n+m)，其中 nn 和 mm 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)O(n+m)。</p>
<p>空间复杂度：O(n + m)O(n+m)，其中 nn 和 mm 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+mn+m 次，因此空间复杂度为 O(n+m)O(n+m)。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：链表集合</li>
        <li>Post author：Yuxuan Wu</li>
        <li>Create time：2021-06-21 21:18:13</li>
        <li>
            Post link：yuxuanwu17.github.io2021/06/21/2021-06-22-链表集合/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/06/29/2021-06-29-Java-%E4%B8%AD%E2%80%9Cwhile-(n--0)%E2%80%9D-%E5%92%8C-%E2%80%9Cwhile-(n!-=0)%E2%80%9D%E5%8C%BA%E5%88%AB/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Java 中“while (n--&gt;0)” 和 “while (n! =0)”区别</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/06/17/2021-06-01-Key-notes-for-Deep-learning-new-computational-modelling-techniques-for-genomics/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Key notes for Deep learning in new computational modeling techniques for genomics</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span> -
            
            2022 <i class="fas fa-heart icon-animate"></i> <a href="/">Yuxuan Wu</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count <span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a> | Theme <a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.3.1</a>
        </div>
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">设计链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">单链表结点的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leetcode-%E4%B8%8A%E7%9A%84%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.2.</span> <span class="nav-text">Leetcode 上的测试代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text">单链表实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98"><span class="nav-number">2.</span> <span class="nav-text">LeetCode 算法实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">19. 删除链表的倒数第 N 个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A-%E8%AE%A1%E7%AE%97%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">2.1.1.</span> <span class="nav-text">方法1： 计算链表的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">2.1.2.</span> <span class="nav-text">方法2：双指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">160. 相交链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E8%80%83%E8%99%91"><span class="nav-number">2.2.1.</span> <span class="nav-text">注意考虑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%951"><span class="nav-number">2.2.2.</span> <span class="nav-text">方法1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8I"><span class="nav-number">2.3.</span> <span class="nav-text">141.环形链表I</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%951-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">方法1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%952"><span class="nav-number">2.3.2.</span> <span class="nav-text">方法2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%953-HashSet"><span class="nav-number">2.3.3.</span> <span class="nav-text">方法3 HashSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="nav-number">2.4.</span> <span class="nav-text">环形链表II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">2.4.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%951-2"><span class="nav-number">2.4.2.</span> <span class="nav-text">方法1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="nav-number">2.4.3.</span> <span class="nav-text">方法二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">2.5.</span> <span class="nav-text">203. 移除链表元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%B3%95"><span class="nav-number">2.5.1.</span> <span class="nav-text">迭代解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95"><span class="nav-number">2.5.2.</span> <span class="nav-text">递归解法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">2.6.</span> <span class="nav-text">2. 两数相加</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A-%E6%9B%B4%E5%8A%A0%E5%80%BE%E5%90%91%E4%BA%8E%E6%AC%A1%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.1.</span> <span class="nav-text">方法1： 更加倾向于次方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A"><span class="nav-number">2.6.2.</span> <span class="nav-text">方法二：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">2.6.3.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9-1"><span class="nav-number">2.7.</span> <span class="nav-text">19. 删除链表的倒数第 N 个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">2.7.1.</span> <span class="nav-text">方法一：双指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A-%E8%AE%A1%E7%AE%97%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">2.7.2.</span> <span class="nav-text">方法二： 计算链表的长度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-Merge-Two-Sorted-Lists"><span class="nav-number">2.8.</span> <span class="nav-text">21. Merge Two Sorted Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%951-%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95-%EF%BC%9A"><span class="nav-number">2.8.1.</span> <span class="nav-text">方法1(迭代算法)：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%952%EF%BC%88ArrayList%EF%BC%89"><span class="nav-number">2.8.2.</span> <span class="nav-text">方法2（ArrayList）:</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
