<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Welcome to my personal blogs">
    <meta name="author" content="Yuxuan Wu">
    
    <title>
        
            线程、同步 |
        
        Yuxuan Wu
    </title>
    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep coding, Keep hungry."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.3.1"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days age","week":"%s weeks age","month":"%s months age","year":"%s years age"};
  </script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Yuxuan Wu
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content normal-code-theme">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">线程、同步</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Yuxuan Wu</span>
                        <span class="level">Lv11</span>
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i> 2021-04-22 23:00:13
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/Java/">Java</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/Java/">Java</a>
                    </li>
                
                    <li>
                        | <a href="/tags/notes/">notes</a>
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i> <span>9.8k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i> <span>39 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i> <span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="线程、同步"><a href="#线程、同步" class="headerlink" title="线程、同步"></a>线程、同步</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li><p>线程</p>
</li>
<li><p>同步</p>
</li>
<li><p>线程状态</p>
</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够描述Java中多线程运行原理</li>
<li><input disabled="" type="checkbox"> 能够使用继承类的方式创建多线程</li>
<li><input disabled="" type="checkbox"> 能够使用实现接口的方式创建多线程</li>
<li><input disabled="" type="checkbox"> 能够说出实现接口方式的好处</li>
<li><input disabled="" type="checkbox"> 能够解释安全问题的出现的原因</li>
<li><input disabled="" type="checkbox"> 能够使用同步代码块解决线程安全问题</li>
<li><input disabled="" type="checkbox"> 能够使用同步方法解决线程安全问题</li>
<li><input disabled="" type="checkbox"> 能够说出线程6个状态的名称</li>
</ul>
<h1 id="第一章-线程"><a href="#第一章-线程" class="headerlink" title="第一章 线程"></a>第一章 线程</h1><h2 id="1-1-多线程原理"><a href="#1-1-多线程原理" class="headerlink" title="1. 1 多线程原理"></a>1. 1 多线程原理</h2><p>昨天的时候我们已经写过一版多线程的代码，很多同学对原理不是很清楚，那么我们今天先画个多线程执行时序来体现一下多线程程序的执行流程。</p>
<p>代码如下：</p>
<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 利用继承中的特点</span></span><br><span class="line"><span class="comment">* 将线程名称传递 进行设置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 重写run方法</span></span><br><span class="line"><span class="comment">* 定义线程要执行的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line">			<span class="comment">//getName()方法 来自父亲</span></span><br><span class="line">			System.out.println(getName()+i);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里是main线程&quot;</span>);</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">&quot;小强&quot;</span>);</span><br><span class="line">        mt.start();<span class="comment">//开启了一个新的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line">        		System.out.println(<span class="string">&quot;旺财:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423110607.png" alt="线程流程图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423111220.bmp" alt="01_多线程随机性打印结果"></p>
<p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。</p>
<p>通过这张图我们可以很清晰的看到多线程的执行流程，那么为什么可以完成并发执行呢？我们再来讲一讲原理。</p>
<p>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明：</p>
<p>多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423111056.bmp" alt="栈内存原理图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423112046.bmp" alt="02_多线程内存图解"></p>
<p>当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p>
<h2 id="1-2-Thread类"><a href="#1-2-Thread类" class="headerlink" title="1. 2 Thread类"></a>1. 2 Thread类</h2><p>在上一天内容中我们已经可以完成最基本的线程开启，那么在我们完成操作过程中用到了java.lang.Thread类，<br>API中该类中定义了有关线程的一些方法，具体如下：</p>
<p>构造方法：</p>
<ul>
<li><code>public Thread():</code>分配一个新的线程对象。</li>
<li>  <code>public Thread(String name):</code>分配一个指定名字的新的线程对象。</li>
<li>  <code>public Thread(Runnable target):</code>分配一个带有指定目标新的线程对象。</li>
<li>  <code>public Thread(Runnable target,String name):</code>分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>public String getName():</code>获取当前线程名称。</li>
<li><code>public void start():</code>导致此线程开始执行; Java虚拟机调用此线程的run方法。</li>
<li><code>public void run():</code>此线程要执行的任务在此处定义代码。</li>
<li><code>public static void sleep(long millis):</code>使当前正在执行的线程以指定的毫秒数暂- 停（暂时停止执行）。</li>
<li><code>public static Thread currentThread()</code>:返回对当前正在执行的线程对象的引用。</li>
</ul>
<p>翻阅API后得知创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式，方式一我们上一天已经完成，接下来讲解方式二实现的方式。</p>
<h3 id="getName"><a href="#getName" class="headerlink" title="getName()"></a>getName()</h3><p><code>获取线程的名称</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01.getName;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取线程的名称:</span></span><br><span class="line"><span class="comment">        1.使用Thread类中的方法getName()</span></span><br><span class="line"><span class="comment">            String getName() 返回该线程的名称。</span></span><br><span class="line"><span class="comment">        2.可以先获取到当前正在执行的线程,使用线程中的方法getName()获取线程的名称</span></span><br><span class="line"><span class="comment">            static Thread currentThread() 返回对当前正在执行的线程对象的引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 定义一个Thread类的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//重写Thread类中的run方法,设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取线程名称</span></span><br><span class="line">        <span class="comment">//String name = getName();</span></span><br><span class="line">        <span class="comment">//System.out.println(name);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread t = Thread.currentThread();</span></span><br><span class="line">        <span class="comment">//System.out.println(t);//Thread[Thread-0,5,main]</span></span><br><span class="line">        <span class="comment">//String name = t.getName();</span></span><br><span class="line">        <span class="comment">//System.out.println(name);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>测试类</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo01.getName;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    线程的名称:</span></span><br><span class="line"><span class="comment">        主线程: main</span></span><br><span class="line"><span class="comment">        新线程: Thread-0,Thread-1,Thread-2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01GetThreadName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Thread类的子类对象</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//调用start方法,开启新线程,执行run方法</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链式编程</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="setName"><a href="#setName" class="headerlink" title="setName"></a>setName</h3><p><code>测试类</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.setName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01SetThreadName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开启多线程</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.setName(<span class="string">&quot;小强&quot;</span>);</span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启多线程</span></span><br><span class="line">        <span class="keyword">new</span> MyThread(<span class="string">&quot;旺财&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>set类</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo02.setName;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置线程的名称:(了解)</span></span><br><span class="line"><span class="comment">        1.使用Thread类中的方法setName(名字)</span></span><br><span class="line"><span class="comment">            void setName(String name) 改变线程名称，使之与参数 name 相同。</span></span><br><span class="line"><span class="comment">        2.创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字</span></span><br><span class="line"><span class="comment">            Thread(String name) 分配新的 Thread 对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);<span class="comment">//把线程名称传递给父类,让父类(Thread)给子线程起一个名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取线程的名称</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo03.sleep;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span></span><br><span class="line"><span class="comment">    毫秒数结束之后,线程继续执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Sleep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//模拟秒表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">60</span> ; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用Thread类的sleep方法让程序睡眠1秒钟</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-3-创建线程方式二"><a href="#1-3-创建线程方式二" class="headerlink" title="1. 3 创建线程方式二"></a>1. 3 创建线程方式二</h2><p>采用<code>java.lang.Runnable</code>也是非常常见的一种，我们只需要重写run方法即可。</p>
<p>步骤如下：</p>
<ol>
<li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。</li>
<li>调用线程对象的start()方法来启动线程。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建自定义类对象 线程任务对象</span></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr, <span class="string">&quot;小强&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;旺财 &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p>
<p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调Thread对象的start()方法来运行多线程代码。</p>
<p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p>
<blockquote>
<p>tips:Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。<br>而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p>
</blockquote>
<p><code>demo in class</code></p>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo04.Runnable;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建多线程程序的第二种方式:实现Runnable接口</span></span><br><span class="line"><span class="comment">    java.lang.Runnable</span></span><br><span class="line"><span class="comment">        Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法。</span></span><br><span class="line"><span class="comment">    java.lang.Thread类的构造方法</span></span><br><span class="line"><span class="comment">        Thread(Runnable target) 分配新的 Thread 对象。</span></span><br><span class="line"><span class="comment">        Thread(Runnable target, String name) 分配新的 Thread 对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现步骤:</span></span><br><span class="line"><span class="comment">        1.创建一个Runnable接口的实现类</span></span><br><span class="line"><span class="comment">        2.在实现类中重写Runnable接口的run方法,设置线程任务</span></span><br><span class="line"><span class="comment">        3.创建一个Runnable接口的实现类对象</span></span><br><span class="line"><span class="comment">        4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line"><span class="comment">        5.调用Thread类中的start方法,开启新的线程执行run方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    实现Runnable接口创建多线程程序的好处:</span></span><br><span class="line"><span class="comment">        1.避免了单继承的局限性</span></span><br><span class="line"><span class="comment">            一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类</span></span><br><span class="line"><span class="comment">            实现了Runnable接口,还可以继承其他的类,实现其他的接口</span></span><br><span class="line"><span class="comment">        2.增强了程序的扩展性,降低了程序的耦合性(解耦)</span></span><br><span class="line"><span class="comment">            实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦)</span></span><br><span class="line"><span class="comment">            实现类中,重写了run方法:用来设置线程任务</span></span><br><span class="line"><span class="comment">            创建Thread类对象,调用start方法:用来开启新线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建一个Runnable接口的实现类对象</span></span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="comment">//4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        <span class="comment">//Thread t = new Thread(run);//打印线程名称</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableImpl2());<span class="comment">//打印HelloWorld</span></span><br><span class="line">        <span class="comment">//5.调用Thread类中的start方法,开启新的线程执行run方法</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口类-1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo04.Runnable;</span><br><span class="line"><span class="comment">//1.创建一个Runnable接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2.在实现类中重写Runnable接口的run方法,设置线程任务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1-4-Thread和Runnable的区别"><a href="#1-4-Thread和Runnable的区别" class="headerlink" title="1. 4 Thread和Runnable的区别"></a>1. 4 Thread和Runnable的区别</h2><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p>
<p><strong>总结：</strong></p>
<p><strong>实现Runnable接口比继承Thread类所具有的优势：</strong></p>
<ol>
<li>适合多个相同的程序代码的线程去共享同一个资源。</li>
<li>可以避免java中的单继承的局限性。（类继承了Thread类就不能继承其他的类实现了Runnable接口,还可以继承其他的类,实现其他的接口）</li>
<li>增加程序的健壮性，实现<code>解耦</code>操作，代码可以被多个线程共享，代码和线程独立。</li>
<li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li>
</ol>
<blockquote>
<p>扩充：在java中，每次程序运行至少启动 2 个线程。一个是main线程，一个是垃圾收集线程。因为每当使用<br>java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进<br>程。</p>
</blockquote>
<h2 id="1-5-匿名内部类方式实现线程的创建"><a href="#1-5-匿名内部类方式实现线程的创建" class="headerlink" title="1. 5 匿名内部类方式实现线程的创建"></a>1. 5 匿名内部类方式实现线程的创建</h2><p>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</p>
<p>使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoNameInnerClassThread</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// new Runnable()&#123;</span></span><br><span class="line">    <span class="comment">// public void run()&#123;</span></span><br><span class="line">        <span class="comment">// for (int i =  0 ; i &lt;  20 ; i++) &#123;</span></span><br><span class="line">        <span class="comment">// System.out.println(&quot;张宇:&quot;+i);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;; //‐‐‐这个整体 相当于new MyRunnable()</span></span><br><span class="line">Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">0</span> ; i &lt;  <span class="number">20</span> ; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;张宇:&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;<span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure>
<p><code>demo in class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo05.InnerClassThread;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    匿名内部类方式实现线程的创建</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    匿名:没有名字</span></span><br><span class="line"><span class="comment">    内部类:写在其他类内部的类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    匿名内部类作用:简化代码</span></span><br><span class="line"><span class="comment">        把子类继承父类,重写父类的方法,创建子类对象合一步完成</span></span><br><span class="line"><span class="comment">        把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成</span></span><br><span class="line"><span class="comment">    匿名内部类的最终产物:子类/实现类对象,而这个类没有名字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    格式:</span></span><br><span class="line"><span class="comment">        new 父类/接口()&#123;</span></span><br><span class="line"><span class="comment">            重复父类/接口中的方法</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01InnerClassThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程的父类是Thread</span></span><br><span class="line">        <span class="comment">// new MyThread().start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="comment">//重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+<span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程的接口Runnable</span></span><br><span class="line">        <span class="comment">//Runnable r = new RunnableImpl();//多态</span></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="comment">//重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+<span class="string">&quot;程序员&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简化接口的方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="comment">//重写run方法,设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+<span class="string">&quot;传智播客&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第二章-线程安全"><a href="#第二章-线程安全" class="headerlink" title="第二章 线程安全"></a>第二章 线程安全</h1><h2 id="2-1-线程安全"><a href="#2-1-线程安全" class="headerlink" title="2. 1 线程安全"></a>2. 1 线程安全</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>我们通过一个案例，演示线程的安全问题：</p>
<p>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共 100 个(本场电影只能卖 100 张票)。</p>
<p>我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这 100 张票)需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟</p>
<p>提高安全问题产生的概率</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423140044.bmp" alt="03_线程安全问题的概述"></p>
<p>模拟票：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作</span></span><br><span class="line">        <span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                <span class="comment">//出票操作</span></span><br><span class="line">                <span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket‐‐);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程任务对象</span></span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"><span class="comment">//创建三个窗口对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(ticket, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(ticket, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(ticket, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"><span class="comment">//同时卖票</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果中有一部分这样现象：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423141454.png" alt="线程安全问题"></p>
<p>发现程序出现了两个问题：</p>
<ol>
<li><p>相同的票数,比如 5 这张票被卖了两回。</p>
</li>
<li><p>不存在的票，比如 0 票与- 1 票，是不存在的。</p>
</li>
</ol>
<p>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。<code>多线程访问共享的对象</code></p>
<p>线程安全问题都是由<code>全局变量及静态变量</code>引起的。若每个线程中<code>对全局变量、静态变量只有读操作</code>，<code>而无写操作</code>，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑<code>线程同步</code>，否则的话就可能影响线程安全。</p>
<p><code>demo in class</code></p>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo06.ThreadSafe;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    模拟卖票案例</span></span><br><span class="line"><span class="comment">    创建3个线程,同时开启,对共享的票进行出售</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口的实现类对象</span></span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="comment">//创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        <span class="comment">//调用start方法开启多线程</span></span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo06.ThreadSafe;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现卖票案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//票存在,卖票 ticket--</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423142610.bmp" alt="04_线程安全问题产生的原理"></p>
<h2 id="2-2-线程同步"><a href="#2-2-线程同步" class="headerlink" title="2. 2 线程同步"></a>2. 2 线程同步</h2><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p>
<p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制**(synchronized)**来解决。</p>
<p>根据案例简述：</p>
<blockquote>
<p>窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。</p>
</blockquote>
<p>为了保证每个线程都能正常执行原子操作, java引入了线程同步机制。</p>
<p>那么怎么去使用呢？有三种方式完成同步操作：</p>
<ol>
<li><p>同步代码块。</p>
</li>
<li><p>同步方法。</p>
</li>
<li><p>锁机制。</p>
</li>
</ol>
<h2 id="2-3-同步代码块"><a href="#2-3-同步代码块" class="headerlink" title="2. 3 同步代码块"></a>2. 3 同步代码块</h2><ul>
<li>同步代码块：<code>synchronized</code>关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li>
</ul>
<p>格式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">        需要同步操作的代码</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><strong>同步锁:</strong></p>
<p>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p>
<ol>
<li><p>锁对象 可以是任意类型。</p>
</li>
<li><p>多个线程对象 要使用同一把锁。</p>
</li>
</ol>
<blockquote>
<p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。</p>
</blockquote>
<p>使用同步代码块解决代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//每个窗口卖票的操作</span></span><br><span class="line"><span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;<span class="comment">//有票 可以卖</span></span><br><span class="line"><span class="comment">//出票操作</span></span><br><span class="line"><span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;正在卖:&quot;</span> + ticket‐‐);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用了同步代码块后，上述的线程的安全问题，解决了。</p>
<p><code>demo in class</code></p>
<p>实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.Synchronized;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    模拟卖票案例</span></span><br><span class="line"><span class="comment">    创建3个线程,同时开启,对共享的票进行出售</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口的实现类对象</span></span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        <span class="comment">//创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        <span class="comment">//调用start方法开启多线程</span></span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo07.Synchronized;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    卖票案例出现了线程安全问题</span></span><br><span class="line"><span class="comment">    卖出了不存在的票和重复的票</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    解决线程安全问题的一种方案:使用同步代码块</span></span><br><span class="line"><span class="comment">    格式:</span></span><br><span class="line"><span class="comment">        synchronized(锁对象)&#123;</span></span><br><span class="line"><span class="comment">            可能会出现线程安全问题的代码(访问了共享数据的代码)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意:</span></span><br><span class="line"><span class="comment">        1.通过代码块中的锁对象,可以使用任意的对象</span></span><br><span class="line"><span class="comment">        2.但是必须保证多个线程使用的锁对象是同一个</span></span><br><span class="line"><span class="comment">        3.锁对象作用:</span></span><br><span class="line"><span class="comment">            把同步代码块锁住,只让一个线程在同步代码块中执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个锁对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">           <span class="comment">//同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="comment">//先判断票是否存在</span></span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//票存在,卖票 ticket--</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423145119.bmp" alt="05_同步的原理"></p>
<h2 id="2-4-同步方法"><a href="#2-4-同步方法" class="headerlink" title="2. 4 同步方法"></a>2. 4 同步方法</h2><ul>
<li><strong>同步方法</strong>:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外<br>等着。</li>
</ul>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        可能会产生线程安全问题的代码</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同步锁是谁?</p>
<p>对于非static方法,同步锁就是this。</p>
<p>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p>
</blockquote>
<p>使用同步方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//每个窗口卖票的操作</span></span><br><span class="line"><span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 锁对象 是 谁调用这个方法 就是谁</span></span><br><span class="line"><span class="comment">     * 隐含 锁对象 就是 this</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line"><span class="comment">//出票操作</span></span><br><span class="line"><span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                e.printStackTrace();&#125;</span><br><span class="line"><span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name+<span class="string">&quot;正在卖:&quot;</span>+ticket+<span class="string">&quot;‐‐&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>demo in class</code></p>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo08.Synchronized;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    模拟卖票案例</span></span><br><span class="line"><span class="comment">    创建3个线程,同时开启,对共享的票进行出售</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Ticket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Runnable接口的实现类对象</span></span><br><span class="line">        RunnableImpl run = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">        System.out.println(<span class="string">&quot;run:&quot;</span>+run);<span class="comment">//run:com.itheima.demo08.Synchronized.RunnableImpl@58ceff1</span></span><br><span class="line">        <span class="comment">//创建Thread类对象,构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        Thread t0 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        <span class="comment">//调用start方法开启多线程</span></span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo08.Synchronized;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    卖票案例出现了线程安全问题</span></span><br><span class="line"><span class="comment">    卖出了不存在的票和重复的票</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    解决线程安全问题的二种方案:使用同步方法</span></span><br><span class="line"><span class="comment">    使用步骤:</span></span><br><span class="line"><span class="comment">        1.把访问了共享数据的代码抽取出来,放到一个方法中</span></span><br><span class="line"><span class="comment">        2.在方法上添加synchronized修饰符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    格式:定义方法的格式</span></span><br><span class="line"><span class="comment">    修饰符 synchronized 返回值类型 方法名(参数列表)&#123;</span></span><br><span class="line"><span class="comment">        可能会出现线程安全问题的代码(访问了共享数据的代码)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this:&quot;</span>+<span class="keyword">this</span>);<span class="comment">//this:com.itheima.demo08.Synchronized.RunnableImpl@58ceff1</span></span><br><span class="line">        <span class="comment">//使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            payTicketStatic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        静态的同步方法</span></span><br><span class="line"><span class="comment">        锁对象是谁?</span></span><br><span class="line"><span class="comment">        不能是this</span></span><br><span class="line"><span class="comment">        this是创建对象之后产生的,静态方法优先于对象</span></span><br><span class="line"><span class="comment">        静态方法的锁对象是本类的class属性--&gt;class文件对象(反射)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">payTicketStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (RunnableImpl.class)&#123;</span><br><span class="line">            <span class="comment">//先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//票存在,卖票 ticket--</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义一个同步方法</span></span><br><span class="line"><span class="comment">        同步方法也会把方法内部的代码锁住</span></span><br><span class="line"><span class="comment">        只让一个线程执行</span></span><br><span class="line"><span class="comment">        同步方法的锁对象是谁?</span></span><br><span class="line"><span class="comment">        就是实现类对象 new RunnableImpl()</span></span><br><span class="line"><span class="comment">        也是就是this</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="comment">//先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//票存在,卖票 ticket--</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-5-Lock锁"><a href="#2-5-Lock锁" class="headerlink" title="2. 5 Lock锁"></a>2. 5 Lock锁</h2><p><code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</p>
<p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p>
<ul>
<li><code>public void lock():</code>加同步锁。</li>
<li><code>public void unlock():</code>释放同步锁。</li>
</ul>
<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//每个窗口卖票的操作</span></span><br><span class="line"><span class="comment">//窗口 永远开启</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line"><span class="comment">//出票操作</span></span><br><span class="line"><span class="comment">//使用sleep模拟一下出票时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name+<span class="string">&quot;正在卖:&quot;</span>+ticket‐‐);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>demo in class</code></p>
<p>测试类同前</p>
<p>锁类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo09.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    卖票案例出现了线程安全问题</span></span><br><span class="line"><span class="comment">    卖出了不存在的票和重复的票</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    解决线程安全问题的三种方案:使用Lock锁</span></span><br><span class="line"><span class="comment">    java.util.concurrent.locks.Lock接口</span></span><br><span class="line"><span class="comment">    Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。</span></span><br><span class="line"><span class="comment">    Lock接口中的方法:</span></span><br><span class="line"><span class="comment">        void lock()获取锁。</span></span><br><span class="line"><span class="comment">        void unlock()  释放锁。</span></span><br><span class="line"><span class="comment">    java.util.concurrent.locks.ReentrantLock implements Lock接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    使用步骤:</span></span><br><span class="line"><span class="comment">        1.在成员位置创建一个ReentrantLock对象</span></span><br><span class="line"><span class="comment">        2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</span></span><br><span class="line"><span class="comment">        3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.在成员位置创建一个ReentrantLock对象</span></span><br><span class="line">    Lock l = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程任务:卖票</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用死循环,让卖票操作重复执行</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</span></span><br><span class="line">            l.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先判断票是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    <span class="comment">//票存在,卖票 ticket--</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</span></span><br><span class="line">                    l.unlock();<span class="comment">//无论程序是否异常,都会把锁释放</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*//设置线程任务:卖票</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void run() &#123;</span></span><br><span class="line"><span class="comment">        //使用死循环,让卖票操作重复执行</span></span><br><span class="line"><span class="comment">        while(true)&#123;</span></span><br><span class="line"><span class="comment">           //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</span></span><br><span class="line"><span class="comment">           l.lock();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            //先判断票是否存在</span></span><br><span class="line"><span class="comment">            if(ticket&gt;0)&#123;</span></span><br><span class="line"><span class="comment">                //提高安全问题出现的概率,让程序睡眠</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    Thread.sleep(10);</span></span><br><span class="line"><span class="comment">                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                    e.printStackTrace();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                //票存在,卖票 ticket--</span></span><br><span class="line"><span class="comment">                System.out.println(Thread.currentThread().getName()+&quot;--&gt;正在卖第&quot;+ticket+&quot;张票&quot;);</span></span><br><span class="line"><span class="comment">                ticket--;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</span></span><br><span class="line"><span class="comment">            l.unlock();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="第三章-线程状态"><a href="#第三章-线程状态" class="headerlink" title="第三章 线程状态"></a>第三章 线程状态</h1><h2 id="3-1-线程状态概述"><a href="#3-1-线程状态概述" class="headerlink" title="3.1 线程状态概述"></a>3.1 线程状态概述</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中java.lang.Thread.State 这个枚举中给出了六种线程状态：</p>
<p>这里先列出各个线程状态发生的条件，下面将会对每种状态进行详细解析</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423152028.png" alt="image-20210423152027930"></p>
<p>我们不需要去研究这几种状态的实现原理，我们只需知道在做线程操作中存在这样的状态。那我们怎么去理解几个状态呢，新建与被终止还是很容易理解的，我们就研究一下线程从Runnable（可运行）状态与非运行状态之间的转换问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423152335.bmp" alt="线程的状态图"></p>
<h2 id="3-2-Timed-Waiting（计时等待）"><a href="#3-2-Timed-Waiting（计时等待）" class="headerlink" title="3. 2 Timed Waiting（计时等待）"></a>3. 2 Timed Waiting（计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？</p>
<p>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠<strong>（暂停执行）</strong>，以“减慢线程”。</p>
<p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等<br>待)，那么我们通过一个案例加深对该状态的一个理解。</p>
<p>实现一个计数器，计数到 100 ，在每个数字之间暂停 1 秒，每隔 10 个数字输出一个字符串</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐&quot;</span> + i);&#125;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.print(<span class="string">&quot; 线程睡眠1秒！\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点：</p>
<ol>
<li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协<br>作关系。</li>
<li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠</li>
<li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</li>
</ol>
<blockquote>
<p>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。</p>
</blockquote>
<p>Timed Waiting 线程状态图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423152621.png" alt="计时等待"></p>
<h2 id="3-3-BLOCKED（锁阻塞）"><a href="#3-3-BLOCKED（锁阻塞）" class="headerlink" title="3. 3 BLOCKED（锁阻塞）"></a>3. 3 BLOCKED（锁阻塞）</h2><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。</p>
<p>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获<br>取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p>
<p>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而<br>这部分内容作为扩充知识点带领大家了解一下。</p>
<p>Blocked 线程状态图</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423152918.png" alt="锁阻塞"></p>
<h2 id="3-4-Waiting（无限等待）"><a href="#3-4-Waiting（无限等待）" class="headerlink" title="3. 4 Waiting（无限等待）"></a>3. 4 Waiting（无限等待）</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p>
<p>那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来学习一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 演示waiting</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println( Thread.currentThread().getName() +<span class="string">&quot;===获取到锁对象，调用wait方法，进入waiting状态，释放锁对象&quot;</span>);</span><br><span class="line">                            obj.wait(); <span class="comment">//无限等待</span></span><br><span class="line"><span class="comment">//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println( Thread.currentThread().getName() + <span class="string">&quot;=== 从waiting状态醒来，获取到锁对象，继续执行了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;等待线程&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// while (true)&#123; //每隔3秒 唤醒一次</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println( Thread.currentThread().getName() +<span class="string">&quot;‐‐‐‐‐ 等待3秒钟&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                    System.out.println( Thread.currentThread().getName() +<span class="string">&quot;‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象&quot;</span>);</span><br><span class="line">                            obj.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">        &#125;,<span class="string">&quot;唤醒线程&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423153338.bmp" alt="06_等待唤醒案例分析"></p>
<p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的<br>Object.notify()方法 或 Object.notifyAll()方法。</p>
<p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，<br>多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞<br>争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入<br>了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了<br>notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入<br>Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p>
<p>Waiting 线程状态图</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423153118.png" alt="无限等待"></p>
<p><code>demo in class</code></p>
<p><code>waitAndNotify</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo10.WaitAndNotify;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    等待唤醒案例:线程之间的通信</span></span><br><span class="line"><span class="comment">        创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span></span><br><span class="line"><span class="comment">        创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意:</span></span><br><span class="line"><span class="comment">        顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行</span></span><br><span class="line"><span class="comment">        同步使用的锁对象必须保证唯一</span></span><br><span class="line"><span class="comment">        只有锁对象才能调用wait和notify方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Obejct类中的方法</span></span><br><span class="line"><span class="comment">    void wait()</span></span><br><span class="line"><span class="comment">          在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。</span></span><br><span class="line"><span class="comment">    void notify()</span></span><br><span class="line"><span class="comment">          唤醒在此对象监视器上等待的单个线程。</span></span><br><span class="line"><span class="comment">          会继续执行wait方法之后的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo01WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建锁对象,保证唯一</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建一个顾客线程(消费者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">//一直等着买包子</span></span><br><span class="line">               <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                   <span class="comment">//保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                   <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;告知老板要的包子的种类和数量&quot;</span>);</span><br><span class="line">                       <span class="comment">//调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span></span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           obj.wait();</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//唤醒之后执行的代码</span></span><br><span class="line">                       System.out.println(<span class="string">&quot;包子已经做好了,开吃!&quot;</span>);</span><br><span class="line">                       System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个老板线程(生产者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//一直做包子</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//花了5秒做包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);<span class="comment">//花5秒钟做包子</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;老板5秒钟之后做好包子,告知顾客,可以吃包子了&quot;</span>);</span><br><span class="line">                        <span class="comment">//做好包子之后,调用notify方法,唤醒顾客吃包子</span></span><br><span class="line">                        obj.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>notifyAll methods demo</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo10.WaitAndNotify;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    进入到TimeWaiting(计时等待)有两种方式</span></span><br><span class="line"><span class="comment">    1.使用sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态</span></span><br><span class="line"><span class="comment">    2.使用wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable/Blocked状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    唤醒的方法:</span></span><br><span class="line"><span class="comment">         void notify() 唤醒在此对象监视器上等待的单个线程。</span></span><br><span class="line"><span class="comment">         void notifyAll() 唤醒在此对象监视器上等待的所有线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建锁对象,保证唯一</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建一个顾客线程(消费者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//一直等着买包子</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;顾客1告知老板要的包子的种类和数量&quot;</span>);</span><br><span class="line">                        <span class="comment">//调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            obj.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//唤醒之后执行的代码</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;包子已经做好了,顾客1开吃!&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个顾客线程(消费者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//一直等着买包子</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;顾客2告知老板要的包子的种类和数量&quot;</span>);</span><br><span class="line">                        <span class="comment">//调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            obj.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//唤醒之后执行的代码</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;包子已经做好了,顾客2开吃!&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;---------------------------------------&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个老板线程(生产者)</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//一直做包子</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//花了5秒做包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);<span class="comment">//花5秒钟做包子</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//保证等待和唤醒的线程只能有一个执行,需要使用同步技术</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;老板5秒钟之后做好包子,告知顾客,可以吃包子了&quot;</span>);</span><br><span class="line">                        <span class="comment">//做好包子之后,调用notify方法,唤醒顾客吃包子</span></span><br><span class="line">                        <span class="comment">//obj.notify();//如果有多个等待线程,随机唤醒一个</span></span><br><span class="line">                        obj.notifyAll();<span class="comment">//唤醒所有等待的线程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-补充知识点"><a href="#3-5-补充知识点" class="headerlink" title="3. 5 补充知识点"></a>3. 5 补充知识点</h2><p>到此为止我们已经对线程状态有了基本的认识，想要有更多的了解，详情可以见下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yuxuanwu17/image-hosting/typora/20210423153220.png" alt="线程状态图"></p>
<p>一条有意思的tips:</p>
<blockquote>
<p>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，<br>比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。<br>这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是<br>如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两<br>得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒<br>计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p>
</blockquote>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：线程、同步</li>
        <li>Post author：Yuxuan Wu</li>
        <li>Create time：2021-04-22 23:00:13</li>
        <li>
            Post link：yuxuanwu17.github.io2021/04/22/2021-04-23-线程、同步/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/04/23/2021-04-23-%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92%E6%A1%88%E4%BE%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">线程池、Lambda表达式</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/04/22/2021-04-22-Map/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Map</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span> -
            
            2021 <i class="fas fa-heart icon-animate"></i> <a href="/">Yuxuan Wu</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count <span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a> | Theme <a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.3.1</a>
        </div>
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5"><span class="nav-number">1.</span> <span class="nav-text">线程、同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9"><span class="nav-number">1.1.</span> <span class="nav-text">主要内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%99%E5%AD%A6%E7%9B%AE%E6%A0%87"><span class="nav-number">1.2.</span> <span class="nav-text">教学目标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">第一章 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">1. 1 多线程原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Thread%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">1. 2 Thread类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getName"><span class="nav-number">2.2.1.</span> <span class="nav-text">getName()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setName"><span class="nav-number">2.2.2.</span> <span class="nav-text">setName</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep"><span class="nav-number">2.2.3.</span> <span class="nav-text">sleep</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="nav-number">2.3.</span> <span class="nav-text">1. 3 创建线程方式二</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-Thread%E5%92%8CRunnable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.</span> <span class="nav-text">1. 4 Thread和Runnable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.5.</span> <span class="nav-text">1. 5 匿名内部类方式实现线程的创建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.</span> <span class="nav-text">第二章 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.1.</span> <span class="nav-text">2. 1 线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.2.</span> <span class="nav-text">2. 2 线程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.3.</span> <span class="nav-text">2. 3 同步代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">2. 4 同步方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-Lock%E9%94%81"><span class="nav-number">3.5.</span> <span class="nav-text">2. 5 Lock锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">4.</span> <span class="nav-text">第三章 线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 线程状态概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Timed-Waiting%EF%BC%88%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">3. 2 Timed Waiting（计时等待）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-BLOCKED%EF%BC%88%E9%94%81%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">3. 3 BLOCKED（锁阻塞）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Waiting%EF%BC%88%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">3. 4 Waiting（无限等待）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">4.5.</span> <span class="nav-text">3. 5 补充知识点</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
